(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        //Allow using this built library as an AMD module
        //in another project. That other project will only
        //see this AMD call, not the internal modules in
        //the closure below.
        define(factory);
    } else {
        //Browser globals case. Just assign the
        //result to a property on the global.
        root.Meems = factory();
    }
}(this, function () {
    //almond, and your modules will be inlined here


/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../tools/almond", function(){});

/*global define*/
/**
 * This module provides helper methods for detecting changes in object properties,
 * triggering observers when anything happens.
 *
 * @module observable
 */
define('observable',[],function() {
    /**
     * Represents an observable object.
     * To retrieve the current value, just call as a function without parameters.
     * To change the current value, call as a function, providing the new value as first parameter.
     *
     * @class observable.Observable
     * @constructor
     * @private
     * @param {*} val The initial value.
     */
    function Observable(val) {
        var retFunc = function (newVal) {
            var self = arguments.callee;

            if (newVal === undefined) {
                return self.$currentVal;
            } else {
                var oldValue = self.$currentVal;
                self.$currentVal = newVal;
                self.notify(oldValue, newVal);
                return this;
            }
        };

        retFunc.$currentVal = val;
        retFunc.$observers = [];

        retFunc.subscribe = Observable.prototype.subscribe;
        retFunc.unsubscribe = Observable.prototype.unsubscribe;
        retFunc.notify = Observable.prototype.notify;

        return retFunc;
    }

    /**
     * Subscribe a new observer.
     *
     * @method subscribe
     * @param {Function} callback - The observer to subscribe.
     * @param {*} callback.oldValue - The value of the property before being changed.
     * @param {*} callback.newValue - The new value of the property.
     * @chainable
     */
    Observable.prototype.subscribe = function (callback) {
        this.$observers.push(callback);
        return this;
    };

    /**
     * Remove an existing observer.
     *
     * @method unsubscribe
     * @param {Function} callback - The observer to remove.
     * @param {*} callback.oldValue - The value of the property before being changed.
     * @param {*} callback.newValue - The new value of the property.
     * @chainable
     */
    Observable.prototype.unsubscribe = function (callback) {
        this.$observers.remove(callback);
        return this;
    };

    /**
     * Notify all subscribers that a change has occurred.
     *
     * @method notify
     * @param {*} oldValue - The value of the property before being changed.
     * @param {*} newValue - The new value of the property.
     * @chainable
     */
    Observable.prototype.notify = function (oldValue, newValue) {
        for (var i = 0, ln = this.$observers.length; i < ln; ++i) {
            this.$observers[i].call(this, oldValue, newValue);
        }

        return this;
    };

    /**
     * Helper method for intercepting method calls and invoking notify.
     *
     * @method createProxyMethod
     * @private
     * @param {Function} method - The method to intercept.
     * @return {Function} The method with an interceptor.
     */
    var createProxyMethod = function (method) {
        return function () {
            var oldValue = this.$currentVal;
            method.apply(this.$currentVal, arguments);
            this.notify(oldValue, this.$currentVal);
        };
    };

    /*
     * All array methods that must be intercepted in order to trigger the
     * notify function.
     */
    var arrayMethods = {
        'indexOf': createProxyMethod(Array.prototype.indexOf),
        'push': createProxyMethod(Array.prototype.push),
        'pop': createProxyMethod(Array.prototype.pop),
        'slice': createProxyMethod(Array.prototype.slice),
        'splice': createProxyMethod(Array.prototype.splice),
        'shift': createProxyMethod(Array.prototype.shift),
        'unshift': createProxyMethod(Array.prototype.unshift),
        'reverse': createProxyMethod(Array.prototype.reverse),
        'sort': createProxyMethod(Array.prototype.sort),
        'remove': function (element) {
            var index = this.$currentVal.indexOf(element);
            if (index > -1) {
                this.$currentVal.splice(index, 1);
            }
        },
        'removeAll': function (items) {
            var i, ln, j, ln2, item;

            for (i = 0, ln = items.length; i < ln; ++i) {
                item = items[i];

                for (j = 0, ln2 = this.$currentVal.length; j < ln2; ++j) {
                    if (this.$currentVal[j] === item) {
                        this.$currentVal.splice(j, 1);
                        --j;
                        --ln2;
                    }
                }
            }
        }
    };

    /**
     * @class observable
     */
    var ViewModelTools = {
        /**
         * Creates a new observable property.
         *
         * @method observable
         * @static
         * @param {*} [val] - The initial value for the property.
         * @return {observable.Observable} The new observable.
         */
        observable : function (val) {
            return new Observable(val);
        },

        /**
         * Creates a new observable array.
         * Note that notifications will only be triggered when the structure of the
         * array is changed. Modifications to properties of elements of the array will
         * not be detected. For that, you must define them as observable properties.
         *
         * @method observableArray
         * @static
         * @param {Array} [startArray] - The initial array.
         * @return {observable.Observable} The new observable.
         */
        observableArray : function (startArray) {
            var funcRet = ViewModelTools.observable(startArray || []);
            for (var k in arrayMethods) {
                funcRet[k] = arrayMethods[k];
            }
            return funcRet;
        }
    };

    return ViewModelTools;
});
/*global define*/
/**
 * Contains a set of methods that facilitate several tasks.
 * @module meems-utils
 */
define('meems-utils',[],function () {
    

    var head = (document.head || document.getElementsByTagName('head')[0]),
        supportsTouch = 'ontouchstart' in window,
        pendingDomClassNameChanges = {},
        pendingHtmlMods = {},
        elmId = 0,
        elementsById = {};

    var $userAgent = (function () {
        var m;

        if ((m = /theme=(\w+)/.exec(window.location.search))) {
            return m[1];
        }

        if (navigator.userAgent.match(/iPad|iPhone|iPod/i) != null) {
            return "ios";
        } else if (navigator.userAgent.match(/Android/i) != null) {
            return "android";
        } else if (navigator.userAgent.match(/BlackBerry/i) != null) {
            return "blackberry";
        }

        return "android";
    }());

    var getXmlHttpRequest = function () {
        if (typeof XMLHttpRequest !== 'undefined') {
            return new XMLHttpRequest();
        } else {
            var versions = [
                "MSXML2.XmlHttp.5.0",
                "MSXML2.XmlHttp.4.0",
                "MSXML2.XmlHttp.3.0",
                "MSXML2.XmlHttp.2.0",
                "Microsoft.XmlHttp"
            ];

            var xhr;
            for(var i = 0, len = versions.length; i < len; ++i) {
                try {
                    xhr = new ActiveXObject(versions[i]);
                    return xhr;
                } catch (e) { }
            }
        }
    };

    /**
     * Encodes parameters to URI format.
     *
     * @private
     * @method serializeUrlObj
     * @param obj The object to convert.
     * @param [prefix] A prefix to apply.
     * @return {string} The serialize object.
     */
    var serializeUrlObj = function(obj, prefix) {
        var str = [];

        for (var p in obj) {
            var k = prefix ? prefix + "[" + p + "]" : p,
                v = obj[p];
            str.push(typeof(v) === "object" ?
                serializeUrlObj(v, k) :
                encodeURIComponent(k) + "=" + encodeURIComponent(v));
        }

        return str.join("&");
    }

    function buildPayload(output, params) {
        if (output === 'json') {
            return JSON.stringify(params);
        } else if (output === 'url') {
            return serializeUrlObj(params);
        }
    }

    function decodeResponse(method, text) {
        if (method === 'text') {
            return text;
        } else if (method === 'json') {
            return JSON.parse(text);
        } else if (method === 'xml') {
            var parser = new DOMParser();
            return parser.parseFromString(text, "application/xml");
        }
    }

    var Utils = {
        /**
         * Methods related with AJAX.
         *
         * @class Ajax
         */
        Ajax : {
            /**
             * Make an AJAX request.
             *
             * @method request
             * @param options The necessary data for making the request.
             * @param options.url The URL to send the request to.
             * @param [options.params] The parameters that must be sent.
             * @param [options.method=GET] Which method to use (GET, POST, PUT, DELETE)
             * @param [options.format=url] In which format to encode the parameters (url, json).
             * @param [options.decoding=text] How the response should be decoded (text, json, xml).
             * @param [options.headers] Custom headers to send in the request.
             * @param options.done Called when the response arrives.
             * @param options.done.statusCode The status code of the response.
             * @param [options.done.response] The textual content of the response.
             */
            request : function (options) {
                var xhr = getXmlHttpRequest();

                xhr.onreadystatechange = function () {
                    if(xhr.readyState < 4) {
                        return;
                    }

                    if(xhr.status !== 200) {
                        options.done({
                            statusCode: xhr.status
                        });
                        return;
                    }

                    // all is well
                    if(xhr.readyState === 4) {
                        var decoding = options.decoding || 'text';

                        options.done({
                            statusCode: xhr.status,
                            response: decodeResponse(decoding, xhr.responseText)
                        });
                    }
                };

                var url = options.url,
                    headers = options.headers || {},
                    method = options.method || 'GET',
                    format = options.format || 'url';

                if (method === 'GET') {
                    xhr.open(method, url + "?" + buildPayload('url', options.params), true);
                } else {
                    xhr.open(method, url, true);
                }

                if ("withCredentials" in xhr) {
                    xhr.withCredentials = true;
                }

                if (format === 'url') {
                    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                } else if (format === 'json') {
                    xhr.setRequestHeader("Content-Type", "application/json");
                } else if (format === 'xml') {
                    xhr.setRequestHeader("Content-Type", "application/xml");
                }

                for (var k in headers) {
                    if (headers.hasOwnProperty(k)) {
                        xhr.setRequestHeader(k, headers[k]);
                    }
                }

                if (method === 'GET') {
                    xhr.send();
                } else {
                    xhr.send(buildPayload(format, options.params));
                }
            }
        },

        /**
         * Methods related with function manipulation.
         *
         * @class Fn
         */
        Fn : {
            /**
             * Used for extending classes.

             * @method extend
             * @static
             * @param {Function|Object} newClass The new class that will contain the extended methods.
             * @param {Function} ClassToExtend Base class.
             * @param {Object} newMethods Object with all the new methods.
             */
            extend : function (newClass, ClassToExtend, newMethods) {
                if (typeof newClass === 'function') {
                    newClass.prototype = new ClassToExtend();
                    newClass.constructor = newClass;
                    newClass = newClass.prototype;
                }

                for (var k in newMethods) {
                    if (newMethods.hasOwnProperty(k)) {
                        newClass[k] = newMethods[k];
                    }
                }
            },

            /**
             * Postpones the invocation of a function until the current method chain is finished.
             *
             * @method postPone
             * @static
             * @param {Function} fn The function to be called
             */
            postPone : function (fn) {
                setTimeout(fn, 10);
            },

            /**
             * Binds the 'this' variable of a function to the given variable.
             *
             * @method bind
             * @static
             * @param {Function} fn The function to be bind-ed.
             * @param {Object} self The new 'this'.
             * @return {Function} The bind-ed function.
             */
            bind : function (fn, self) {
                return function () {
                    fn.apply(self, arguments);
                };
            },

            /**
             * Ensures a function is called at most once in the given time interval.
             *
             * @method throttle
             * @static
             * @param {Function} fn The function to be protected.
             * @param {Number} ms How many milliseconds must pass before the function can be called again.
             * @return {Function} The protected function.
             */
            throttle : function (fn, ms) {
                var lastCall, now;
                return function () {
                    now = (new Date()).getTime();
                    if (!lastCall || now - lastCall > ms) {
                        var ret = fn.apply(this, arguments);
                        lastCall = now;
                        return ret;
                    }
                };
            }
        },

        /**
         * All methods related to array manipulation.
         *
         * @class Array
         */
        Array : {
            /**
             * Allows to search an array of objects by a property of those objects.
             *
             * @method indexOfByProp
             * @static
             * @param {Array} arr The array to be searched.
             * @param {String} prop The name of the property to be matched.
             * @param {*} value The value to match.
             * @return {number} The position of the matched element in the array,
             *                   -1 if none matched the criteria.
             */
            indexOfByProp : function (arr, prop, value) {
                for (var i = 0; i < arr.length; ++i) {
                    if (arr[i][prop] === value) {
                        return i;
                    }
                }

                return -1;
            },

            /**
             * Removes an element from an array (in-place).
             *
             * @method remove
             * @static
             * @param {Array} arr The array to remove the element from.
             * @param {mixed} el The element to remove.
             */
            remove : function (arr, el) {
                for (var i = 0, ln = arr.length; i < ln; ++i) {
                    if (arr[i] === el) {
                        arr.splice(i, 0);
                        return;
                    }
                }
            },

            /**
             * Move an element of the array to another position.
             * Stolen from: http://stackoverflow.com/questions/5306680/move-an-array-element-from-one-array-position-to-another
             *
             * @method moveElement
             * @param {Array} arr The array to modify.
             * @param {Number} pos1 The position where the element is at.
             * @param {Number} pos2 The position where the element must be moved to.
             */
            moveElement : function(arr, pos1, pos2) {
                // local variables
                var i, tmp;
                // cast input parameters to integers
                pos1 = parseInt(pos1, 10);
                pos2 = parseInt(pos2, 10);
                // if positions are different and inside array
                if (pos1 !== pos2 && 0 <= pos1 && pos1 <= arr.length && 0 <= pos2 && pos2 <= arr.length) {
                    // save element from position 1
                    tmp = arr[pos1];
                    // move element down and shift other elements up
                    if (pos1 < pos2) {
                        for (i = pos1; i < pos2; i++) {
                            arr[i] = arr[i + 1];
                        }
                    }
                    // move element up and shift other elements down
                    else {
                        for (i = pos1; i > pos2; i--) {
                            arr[i] = arr[i - 1];
                        }
                    }
                    // put element from position 1 to destination
                    arr[pos2] = tmp;
                }
            }
        },

        /**
         * All methods related to map manipulation.
         *
         * @class Map
         */
        Map : {
            /**
             * Extracts all the keys from a map object.
             *
             * @method getKeys
             * @static
             * @param {Object} map The map to extract keys from.
             * @return {String[]} Array with the keys.
             */
            getKeys : function (map) {
                var keys = [];
                
                for (var k in map) {
                    if (map.hasOwnProperty(k)) {
                        keys.push(k);
                    }
                }
                
                return keys;
            }
        },

        /**
         * All methods related with DOM manipulation.
         *
         * @class Dom
         */
        Dom : {
            /**
             * Retrieves the className of an element.
             * Using this method is required when using other methods from this namespace,
             * because it will return the most recent changes (even before calling applyChanges).
             *
             * @method getClass
             * @static
             * @param {HTMLElement} el The element to retrieve the className from.
             * @return {String} The className.
             */
            getClass : function (el) {
                if (!el.$meems_uid) {
                    el.$meems_uid = ++elmId;
                    elementsById[el.$meems_uid] = el;
                    pendingDomClassNameChanges[el.$meems_uid] = el.className;
                } else if (!(el.$meems_uid in pendingDomClassNameChanges) || !pendingDomClassNameChanges[el.$meems_uid]) {
                    pendingDomClassNameChanges[el.$meems_uid] = el.className;
                }
                
                return pendingDomClassNameChanges[el.$meems_uid];
            },

            /**
             * Append a new class name to an element.
             *
             * @method addClass
             * @static
             * @param {HTMLElement} el The element to add the class name to.
             * @param {String} clazz The class name to add.
             */
            addClass : function (el, clazz) {
                var currentClass = this.getClass(el);
                pendingDomClassNameChanges[el.$meems_uid] = currentClass.replace(new RegExp("\\b" + clazz + "\\b"), "") + " " + clazz;
            },

            /**
             * Remove a class name from an element.
             *
             * @method removeClass
             * @static
             * @param {HTMLElement} el Element to remove the class name from.
             * @param {String} clazz The class name to remove.
             */
            removeClass : function (el, clazz) {
                var currentClass = this.getClass(el);
                pendingDomClassNameChanges[el.$meems_uid] = currentClass.replace(new RegExp("\\b" + clazz + "\\b"), "");
            },

            /**
             * Replace the className of an element.
             *
             * @method setClass
             * @static
             * @param {HTMLElement} el The element to set the className of.
             * @param {String} clazz The new className.
             */
            setClass : function (el, clazz)  {
                if (!el.$meems_uid) {
                    el.$meems_uid = ++elmId;
                    elementsById[el.$meems_uid] = el;
                }
                pendingDomClassNameChanges[el.$meems_uid] = clazz;
            },

            /**
             * Set the innerHTML property of an element.
             *
             * @method setHtml
             * @static
             * @param {HTMLElement} el The element to change.
             * @param {String} html The new innerHTML property.
             */
            setHtml : function (el, html) {
                if (!el.$meems_uid) {
                    el.$meems_uid = ++elmId;
                    elementsById[el.$meems_uid] = el;
                }
                pendingHtmlMods[el.$meems_uid] = html;
            },

            /**
             * Applies all the changes made by the addClass, setClass, removeClass, setHtml methods.
             * This is a way to reduce DOM manipulation, speeding up the update process.
             *
             * @method applyChanges
             * @static
             */
            applyChanges : function () {
                var newClassName, newHtml, uid;
                
                for (uid in pendingDomClassNameChanges) {
                    if (pendingDomClassNameChanges.hasOwnProperty(uid)) {
                        newClassName = pendingDomClassNameChanges[uid];
                        if (newClassName) {
                            elementsById[uid].className = newClassName;
                        }
                    }
                }
                
                for (uid in pendingHtmlMods) {
                    if (pendingHtmlMods.hasOwnProperty(uid)) {
                        newHtml = pendingHtmlMods[uid];
                        if (newHtml) {
                            elementsById[uid].innerHTML = newHtml;
                        }
                    }
                }
                
                pendingDomClassNameChanges = {};
                pendingHtmlMods = {};
                
            },

            /**
             * Add a meta tag to the head element, disabling zooming and fixing the viewport.
             * Use only when you can't easily add the tag yourself to the HTML file.
             *
             * @method fixedViewport
             * @static
             */
            fixedViewport : function () {
                var meta = document.createElement("meta");
                meta.setAttribute("name", "viewport");
                meta.setAttribute("content", "width=device-width, initial-scale=1, maximum-scale=1");
                head.appendChild(meta);
            },

            /**
             * Checks if the browser supports touch events.
             *
             * @method supportsTouch
             * @static
             * @return {boolean} True if it supports touch events, false otherwise.
             */
            supportsTouch : function () {
                return supportsTouch;
            },

            /**
             * Retrieves the absolute x and y components of the provided element,
             * relative to its closest parent with position absolute.
             *
             * @method getPosition
             * @param {HTMLElement} el The element to calculate the position of.
             * @return {Object} x and y
             */
            getPosition : function (el) {
                var currentEl = el,
                    ret = {
                        x: 0,
                        y: 0
                    };

                do {
                    ret.x += currentEl.offsetLeft;
                    ret.y += currentEl.offsetTop;
                } while (currentEl = currentEl.offsetParent);

                return ret;
            },

            /**
             * Retrieves the absolute x and y components of the provided element,
             * relative to its closest parent with position absolute and the
             * elements position.
             *
             * @method getRect
             * @param {HTMLElement} el The element to calculate the position of.
             * @return {Object} x, y, width and height
             */
            getRect : function (el) {
                var ret = Utils.Dom.getPosition(el);
                ret.width = el.offsetWidth;
                ret.height = el.offsetHeight;
                return ret;
            },

            /**
             * Retrieves the absolute x and y components of the provided element,
             * relative to its closest parent with position absolute.
             *
             * @method getAbsolutePosition
             * @param {HTMLElement} el The element to calculate the position of.
             * @return {Object} x and y
             */
            getAbsolutePosition : function (el) {
                var currentEl = el,
                    ret = {
                        x: 0,
                        y: 0
                    };

                while (currentEl && currentEl.style.position !== 'absolute') {
                    ret.x += currentEl.offsetLeft;
                    ret.y += currentEl.offsetTop;
                    currentEl = currentEl.offsetParent;
                    break;
                }

                return ret;
            },

            /**
             * Retrieves the dimensions of an element, excluding padding, margins and borders.
             *
             * @method getDimensions
             * @param {HTMLElement} el The element to calculate the dimensions of.
             * @return {Object} width and height
             */
            getDimensions : function (el) {
                var style = window.getComputedStyle(el, null);
                return {
                    width: parseFloat(style.getPropertyValue("width")),
                    height: parseFloat(style.getPropertyValue("height"))
                }
            },

            userAgent : function () {
                return $userAgent;
            }
        }
    };
    
    if (Function.prototype.extend === undefined) {
        Function.prototype.extend = function (baseClass, newMethods) {
            Utils.Fn.extend(this, baseClass, newMethods);
        };
    }
    
    return Utils;
});

/*global define*/
/**
 * Module that provides methods and mixins related with event handling.
 * @module meems-events
 */
define('meems-events',[],function () {
    

    var touchStartEventName, touchEndEventName, touchMoveEventName,
        getCursorPosition;

    if ('ontouchstart' in window) {
        touchStartEventName = 'touchstart';
        touchMoveEventName = 'touchmove';
        touchEndEventName = 'touchend';
        getCursorPosition = function (e) {
            return {
                x : e.touches[0].pageX,
                y : e.touches[0].pageY
            };
        };
    } else {
        touchStartEventName = 'mousedown';
        touchMoveEventName = 'mousemove';
        touchEndEventName = 'mouseup';
        getCursorPosition = function (e) {
            return {
                x : e.pageX,
                y : e.pageY
            };
        };
    }

    /**
     * Provides functions to add and remove event listeners to the DOM.
     *
     * @class DomEvents
     * @private
     * @constructor
     */
    var DomEvents = (function () {
        var hasAddEventListener = 'addEventListener' in window;
        var hasAttachEvent = 'attachEvent' in window;

        function addfn1(el, event, fn) {
            el.addEventListener(event, fn, true);
        }

        function addfn2(el, event, fn) {
            el.attachEvent('on' + event, fn);
        }

        function addfn3(el, event, fn) {
            el['on' + event] = fn;
        }

        function rmfn1(el, event, fn) {
            el.removeEventListener(event, fn, true);
        }

        function rmfn2(el, event, fn) {
            el.detachEvent('on' + event, fn);
        }

        function rmfn3(el, event) {
            el['on' + event] = null;
        }

        return {
            /**
             * Add an event listener to a DOM element.
             * @method on
             * @param {HTMLElement} el The element to add the listener to.
             * @param {String} event The event name.
             * @param {Function} fn The callback function for when the event occurs.
             */
            on: hasAddEventListener ? addfn1 : (hasAttachEvent ? addfn2 : addfn3),

            /**
             * Remove an event listener from a DOM element.
             * @method off
             * @param {HTMLElement} el The element to remove the listener from.
             * @param {String} event The event name.
             * @param {Function} fn The callback function that was previously added.
             */
            off: hasAddEventListener ? rmfn1 : (hasAttachEvent ? rmfn2 : rmfn3),

            /**
             * Cancel an event and prevent the default handler.
             * @method cancelEvent
             * @param {Event} e Event to cancel.
             * @return {Boolean} You must also return this in the event handler.
             */
            cancelEvent: function (e) {
                if (e.preventDefault) {
                    e.preventDefault();
                }

                if (e.stopPropagation) {
                    e.stopPropagation();
                }

                e.cancelBubble = true;
                e.returnValue = false;

                return false;
            }
        };
    }());

    /**
     * Class that enables an object to act as an event handler.
     * @class Handler
     * @constructor
     */
    function Handler() {
        this.$handlers = {};
        return this;
    }

    Handler.prototype = {
        /**
         * Listen for an event.
         *
         * @method on
         * @param {String} eventName The name of the event.
         * @param {Function} fn The callback.
         * @param {String} fn.eventName The name of the event to trigger.
         * @param {...Mixed} fn.args Extra parameters passed to the fire method.
         * @chainable
         */
        on : function (eventName, fn) {
            this.$handlers[eventName] = this.$handlers[eventName] || [];
            this.$handlers[eventName].push(fn);
            return this;
        },

        /**
         * Stop listening for an event.
         *
         * @method off
         * @param {String} eventName The name of the event.
         * @param {Function} fn The callback.
         * @param {String} fn.eventName The name of the event to trigger.
         * @param {Mixed} [fn.args]* Extra parameters passed to the fire method.
         * @chainable
         */
        off : function (eventName, fn)  {
            if (this.$handlers[eventName] !== undefined) {
                this.$handlers[eventName] = this.$handlers[eventName].filter(function (element) {
                    return element !== fn;
                });
            }
            return this;
        },

        /**
         * Fire an event name, triggering all listeners.
         *
         * @method fire
         * @param {String} eventName The name of the event to trigger.
         * @param {...Mixed} args All extra parameters will be passed to the listeners.
         * @chainable
         */
        fire : function (eventName, args) {
            var handlers = this.$handlers[eventName] || [];
            
            for (var i = 0; i < handlers.length; ++i) {
                handlers[i].apply(this, arguments);
            }
            
            return this;
        }
    };

    var Events = {
        Dom: DomEvents,
        Handler: Handler,

        /**
         * @class Touch
         */
        Touch : {
            /**
             * Event name for when the user starts to press the screen.
             *
             * @property touchStartEventName
             * @static
             * @type String
             */
            touchStartEventName : touchStartEventName,
            /**
             * Event name for when the user releases a press on the screen.
             *
             * @property touchEndEventName
             * @static
             * @type String
             */
            touchEndEventName : touchEndEventName,
            /**
             * Event name for when the user moves the finger/cursor on the screen.

             * @property touchMoveEventName
             * @static
             * @type String
             */
            touchMoveEventName : touchMoveEventName,
            /**
             * Transforms an MouseMouve or TouchMouve event into an object
             * with x and y coordinates of the first touch.
             * @method getCursorPosition
             * @static
             * @param {*} e The event object
             * @return {Object} Object with the x and y coordinates.
             */
            getCursorPosition : getCursorPosition
        }
    };
    
    return Events;
});
/*global define*/
/**
 * A base class for all widgets.
 *
 * @module meems-ui
 * @submodule widget
 * @requires meems-utils
 * @requires meems-events
 */
define('ui/widget',["meems-utils", "meems-events"], function (Utils, Events) {
    

    /**
     * @class Widget
     * @constructor
     * @extends Handler
     */
    function Widget() {
        this.$el = null;
        this.$parent = null;
        this.$facets = {};
        this.$attributes = {};
        this.$eventHandlers = null;

        Events.Handler.apply(this, arguments);
        
        return this;
    }

    Widget.extend(Events.Handler, {
        on : function (eventName, fn) {
            if (eventName.indexOf('dom:') === 0) {
                if (this.$el) {
                    Events.Dom.on(this.el(), eventName.substr(4), function () {
                        Array.prototype.unshift.call(arguments, eventName);
                        fn.apply(this, arguments);
                    });
                } else {
                    this.$eventHandlers = this.$eventHandlers || [];
                    this.$eventHandlers.push([ eventName, fn ]);
                }
            } else {
                Events.Handler.prototype.on.apply(this, arguments); //super
            }

            return this;
        },
        
        off : function (eventName, fn) {
            if (eventName.indexOf('dom:') === 0) {
                Events.Dom.off(this.el(), eventName.substr(4), fn);
            } else {
                Events.Handler.prototype.off.apply(this, arguments); //super
            }

            return this;
        },

        fire : function (eventName /*, args */) {
            var elm = this;

            while (elm) {
                Events.Handler.prototype.fire.apply(elm, arguments);
                elm = elm.parent();
            }

            return this;
        },

        /**
         * Setter and getter for the DOMElement associated with this widget.
         * 
         * @method el
         * @param {HTMLElement} [el] New value.
         * @chainable
         * @return {HTMLElement|Widget} If no parameter is provided, the current value is returned.
         * Otherwise, the new value is stored and the Widget itself is returned to allow chaining.
         */
        el : function (el) {
            if (el === undefined) {
                return this.$el;
            } else {
                this.$el = el;

                if (this.$el && this.$eventHandlers) {
                    var ev;
                    for (var i = 0, len = this.$eventHandlers.length; i < len; ++i) {
                        ev = this.$eventHandlers[i];
                        this.on(ev[0], ev[1]);
                    }

                    this.$eventHandlers = null;
                }

                return this;
            }
        },

        /**
         * Returns all the facet names of this widget.
         *
         * @method facets
         * @return {String[]} return the names of all the facets of this widget.
         */
        facets : function () {
            return Utils.Map.getKeys(this.$facets);
        },

        /**
         * Setter and getter for the parent of this widget.
         *
         * @method parent
         * @param {Widget} [val] New parent.
         * @chainable
         * @return {HTMLElement|Widget} If no parameter is provided, the current value is returned.
         * Otherwise, the new value is stored and the Widget itself is returned to allow chaining.
         */
        parent : function (val) {
            if (val === undefined) {
                return this.$parent;
            } else {
                this.$parent = val;
                return this;
            }
        },

        /**
         * Setter and getter for the facets of this widget.
         *
         * @method facet
         * @param {String} name The name of the facet.
         * @param {Widget} [facet] New content of the facet.
         * @chainable
         * @return {Widget} If no parameter is provided, the current value is returned.
         * Otherwise, the new value is stored and the Widget itself is returned to allow chaining.
         */
        facet : function (name, facet) {
            if (facet === undefined) {
                return this.$facets[name];
            } else {
                if (this.$el && this.$facets[name] && this.$facets[name].el() &&
                    this.$facets[name].el().parentNode === this.$el) {
                    this.$el.removeChild(this.$facets[name].el());
                }
                
                this.$facets[name] = facet;
                return this;
            }
        },

        /**
         * Setter and getter for the attributes of this widget.
         *
         * @method attr
         * @param {String} name The name of the attribute.
         * @param {observable.Observable|mixed} [val] New value of the attribute.
         * @chainable
         * @return {Widget|observable.Observable|mixed} If no parameter is provided, the current value is returned.
         * Otherwise, the new value is stored and the Widget itself is returned to allow chaining.
         */
        attr : function (name, val) {
            if (val === undefined) {
                var value = this.$attributes[name];

                if (typeof value === 'function') {
                    return value();
                } else {
                    return value;
                }
            } else {
                this.$attributes[name] = val;

                if (val && val.subscribe !== undefined && typeof(val.subscribe) === 'function') {
                    val.subscribe((function (name, self) {
                        return Utils.Fn.bind(function(oldValue, newValue) {
                            this.partialUpdate(name, oldValue, newValue);
                        }, self);
                    }(name, this)));
                }

                return this;
            }
        },

        /**
         * Called when an (observable) attribute changes, in order to allow the Widget to update itself.
         *
         * @method partialUpdate
         * @param {String} attrName The name of the attribute that has changed.
         * @param {mixed} oldValue Its old value.
         * @param {mixed} newValue Its new value.
         */
        partialUpdate : function (attrName, oldValue, newValue) {
            this.update();
        },

        /**
         * Called for creating and updating the Widget's DOM nodes.
         *
         * @method update
         * @param {boolean} [structureOnly] If only the DOM structure must be updated.
         */
        update : function (structureOnly) {
            if (this.el() && this.$attributes['customClass']) {
                Utils.Dom.addClass(this.el(), this.$attributes['customClass']);
                this.$attributes['customClass'] = null;
            }
            //Utils.Dom.applyChanges();
        }
    });

    return Widget;
});

/*global define*/
/**
 * A header component, to be used with the Page component.
 * Exposes a 'buttonsleft' and 'buttonsright' facet.
 * The attribute 'title' must be used to set the title of the page.
 *
 * @module meems-ui
 * @submodule header
 * @requires meems-utils
 */
define('ui/header',["meems-utils", "./widget"], function (Utils, Widget) {
    

    var MAX_BUTTONS = 999,
        userAgent = Utils.Dom.userAgent();

    console.log(userAgent);
    if (userAgent === 'ios') {
        MAX_BUTTONS = 1;
    } else {
        MAX_BUTTONS = 2;
    }

    /**
     * @class Header
     * @constructor
     * @extends Widget
     */
    function Header() {
        Widget.apply(this, arguments);
        
        this.facet("buttonsleft", null);
        this.facet("buttonsright", null);
        
        this.$titleEl = null;
        
        return this;
    }
    
    Header.extend(Widget, {
        partialUpdate : function (attrName, oldValue, newValue) {
            if (attrName === "title" && this.$titleEl) {
                Utils.Dom.setHtml(this.$titleEl, "<h1>" + (newValue || "") + "</h1>");
            }
        },

        update : function (structureOnly) {
            if (!this.el()) {
                this.el(document.createElement("div"));
                this.el().className = "ui-header";
                this.$titleEl = document.createElement("div");
                this.$titleEl.className = "ui-title";
                this.el().appendChild(this.$titleEl);
            }

            Utils.Dom.setHtml(this.$titleEl, "<h1>" + (this.attr("title") || "") + "</h1>");

            if (this.facet("buttonsleft")) {
                this.facet("buttonsleft").attr("maxButtons", 1);
                this.facet("buttonsleft").update(structureOnly);
                
                if (this.facet("buttonsleft").el().parentNode !== this.el()) {
                    Utils.Dom.addClass(this.facet("buttonsleft").el(), "ui-buttons-left");
                    this.el().insertBefore(this.facet("buttonsleft").el(), this.$titleEl);
                }
            }
            
            if (this.facet("buttonsright")) {
                this.facet("buttonsright").attr("maxButtons", MAX_BUTTONS);
                this.facet("buttonsright").update(structureOnly);
                
                if (this.facet("buttonsright").el().parentNode !== this.el()) {
                    Utils.Dom.addClass(this.facet("buttonsright").el(), "ui-buttons-right");
                    this.el().appendChild(this.facet("buttonsright").el());
                }
            }
            
            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return Header;
});

/*global define*/
/**
 * A footer component, to be used with the Page component.
 * Exposes a 'buttons' facet.
 *
 * @module meems-ui
 * @submodule footer
 * @requires meems-utils
 */
define('ui/footer',["meems-utils", "./widget"], function (Utils, Widget) {
    

    /**
     * @class Footer
     * @constructor
     * @extends Widget
     */
    function Footer() {
        Widget.apply(this, arguments);
        this.facet("buttons", null);
        return this;
    }
    
    Footer.extend(Widget, {
        update : function (structureOnly) {
            if (!this.el()) {
                this.el(document.createElement("div"));
                Utils.Dom.addClass(this.el(), "ui-footer");
            }
            
            if (this.facet("buttons")) {
                this.facet("buttons").update(structureOnly);
                
                if (this.facet("buttons").el().parentNode !== this.el()) {
                    Utils.Dom.addClass(this.facet("buttons").el(), "ui-buttons");
                    this.el().appendChild(this.facet("buttons").el());
                }
            }
            
            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return Footer;
});

/*global define*/
/**
 * Emulates scrolling on a set of components, with scroll-bars, as if on a mobile environment.
 * @module meems-scroll
 * @requires meems-utils
 * @requires meems-events
 */
define('meems-scroll',["meems-utils", "meems-events"], function (Utils, Events) {
    

    var activeScrollers = [];

    var transitionName = (function () {
        var b = document.body || document.documentElement;
        var transitionNames = [ "transition", "MozTransition", "WebkitTransition", "OTransition", "MsTransition"];

        for (var i = 0; i < transitionNames.length; ++i) {
            if (transitionNames[i] in b.style) {
                return transitionNames[i];
            }
        }
        return "transition";
    }());

    var transformObj = (function () {
        var b = document.body || document.documentElement,
            transformNames = [ "transform", "MozTransform", "WebkitTransform" ],
            ret = {
                cssName: "transition",
                jsName: "transition"
            };

        for (var i = 0; i < transformNames.length; ++i) {
            if (transformNames[i] in b.style) {
                ret.cssName = transformNames[i];
                ret.jsName = ret.cssName.substring(0, 1).toLowerCase() + ret.cssName.substring(1);
                break;
            }
        }

        return ret;
    }()),
        transformName = transformObj.cssName,
        transformNameJs = transformObj.jsName;

    transformObj = null;

    // requestAnimationFrame polyfill by Erik Möller
    // fixes from Paul Irish and Tino Zijdel
     
    (function () {
        var lastTime = 0;
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
            window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
                                       || window[vendors[x] + 'CancelRequestAnimationFrame'];
        }
     
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function (callback/*, element*/) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = window.setTimeout(function () { callback(currTime + timeToCall); },
                  timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };
        }
     
        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = function (id) {
                clearTimeout(id);
            };
        }
    }());
        
    function registerHandlers(elm, config) {
        if (!config.disableTouchEvents) {
            Events.Dom.on(elm, Events.Touch.touchStartEventName, onTouchStart);
            Events.Dom.on(elm, Events.Touch.touchMoveEventName, onTouchMove);
            Events.Dom.on(elm, Events.Touch.touchEndEventName, onTouchEnd);
        }
        
        elm.$meems_scroll = true;
        elm.$meems_config = config;
        
        elm.style.overflow = 'hidden';
        elm.$meems_content.style.position = 'absolute';
    }
    
    function removeHandlers(elm, config) {
        delete elm.$meems_scroll;
        delete elm.$meems_config;
        
        if (!config.disableTouchEvents) {
            Events.Dom.off(elm, Events.Touch.touchStartEventName, onTouchStart);
            Events.Dom.off(elm, Events.Touch.touchMoveEventName, onTouchMove);
            Events.Dom.off(elm, Events.Touch.touchEndEventName, onTouchEnd);
        }
    }
    
    function getFirstParentScroller(e) {
        //var targetType = e.target.tagName.toLowerCase();
        /*if (targetType === 'button' || targetType === 'input' || targetType === 'textarea') {
            return null;
        } */
        
        var node = e.target;

        if (node.className.indexOf("meems-scroll-skip") > -1) {
            return null;
        }
        
        while (node.$meems_scroll === undefined && node.parentNode) {
            node = node.parentNode;
        }
        
        return node;
    }
    
    function calculateFinalPositionAndTime(config, fingerDownPos, fingerUpPos, currentPos,
                                            time, scrollerSize, contentSize) {
        var offsetY = fingerDownPos - fingerUpPos,
            speedY = offsetY / time,
            totalTime = time / config.friction, //Math.abs(speedY / config.friction),
            finalPos = currentPos - speedY * totalTime;

        if (config.paging) {
            if (finalPos > currentPos + scrollerSize) {
                finalPos = currentPos + scrollerSize;
            } else if (finalPos < currentPos - scrollerSize) {
                finalPos = currentPos - scrollerSize;
            }
            
            finalPos = Math.round(finalPos / scrollerSize) * scrollerSize;
        } else if (config.snap && config.snap > 0) {
            finalPos = Math.round(finalPos / config.snap) * config.snap;
        }

        var newFinalPositionY = finalPos;

        if (contentSize < scrollerSize) {
            if (newFinalPositionY < 0) {
                newFinalPositionY = 0;
            }
        } else {
            if (newFinalPositionY < -contentSize + scrollerSize) {
                newFinalPositionY = -contentSize + scrollerSize;
            }
        }
        
        if (newFinalPositionY > 0) {
            newFinalPositionY = 0;
        }
        
        // recalculate time
        if (finalPos !== newFinalPositionY) {
            totalTime = totalTime * Math.abs((fingerDownPos - newFinalPositionY) / (fingerDownPos - finalPos));
            finalPos = newFinalPositionY;
        }

        if (totalTime > config.totalMaxTime) {
            totalTime = config.totalMaxTime;
        }

        return [finalPos, totalTime];
    }
    
    var $scrollersDragging = 0;
    var $mouseIsDown = false;

    function onDocumentTouchStart() {
        $mouseIsDown = true;
    }

    function onDocumentTouchEnd() {
        $mouseIsDown = false;
    }

    function onTouchStart(e) {
        var scroller = getFirstParentScroller(e);

        if (!scroller) {
            return true;
        }

        var content = scroller.$meems_content,
            oldX = (scroller.$meems_content_size ? scroller.$meems_content_size.left || 0 : 0),
            oldY = (scroller.$meems_content_size ? scroller.$meems_content_size.top || 0 : 0);

        content.style[transitionName] = "";

        scroller.$meems_content_size = getObjectDimensions(content);
        scroller.$meems$elm_size = getObjectDimensions(scroller);

        scroller.$meems_content_size.left = oldX;
        scroller.$meems_content_size.top = oldY;

        scroller.$meems_old_pos = {
            x: scroller.$meems_content_size.left,
            y: scroller.$meems_content_size.top
        };

        scroller.$meems_dragging = true;
        scroller.$meems_dragging_start = (new Date()).getTime();
        scroller.$meems_cursor_pos = Events.Touch.getCursorPosition(e);
        scroller.$meems_cursor_last_pos = scroller.$meems_cursor_pos;
        scroller.$meems_scrolling_running_animation = false;
        scroller.$meems_drag_distance = 0;
        scroller.$meems_effective_drag_distance = 0;
        scroller.$meems_locked_axis = undefined;

        ++$scrollersDragging;

        updateScrollbarsSize(scroller);

        return true;
        //return cancelEvent(e);
    }

    function scrollUpOrDownAccordingToEvent(e) {
        if (!$mouseIsDown) {
            return;
        }

        var scroller = getFirstParentScroller(e);
        if (!scroller) {
            return;
        }

        var content = scroller.$meems_content,
            oldX = (scroller.$meems_content_size ? scroller.$meems_content_size.left || 0 : 0),
            oldY = (scroller.$meems_content_size ? scroller.$meems_content_size.top || 0 : 0);

        scroller.$meems_content_size = getObjectDimensions(content);
        scroller.$meems_content_size.left = oldX;
        scroller.$meems_content_size.top = oldY;

        var pos = Events.Touch.getCursorPosition(e),
            config = scroller.$meems_config,
            scrollerPosition = Utils.Dom.getPosition(scroller),
            scrollerHeight = scroller.$meems$elm_size.height,
            contentHeight = scroller.$meems_content_size.height;

        if (config.scrollY) {
            var dir = 0;

            if (pos.y - scrollerPosition.y <= 100) {
                dir = 50;
            } else if (scrollerPosition.y + scrollerHeight - pos.y <= 100) {
                dir = -50;
            }

            if (dir !== 0) {
                var finalY = calculateFinalPositionAndTime({
                        paging: false,
                        snap: false,
                        totalMaxTime: 0.50,
                        friction: config.friction
                    }, 0, dir, scroller.$meems_content_size.top, 0.50, scrollerHeight, contentHeight),
                    finalYPos = finalY[0],
                    finalYPosTime = finalY[1];

                scrollAux(scroller, null, null, finalYPos, finalYPosTime);
            }
        }
    }

    function onTouchMove(e) {
        if (!$mouseIsDown || $scrollersDragging <= 0) {
            scrollUpOrDownAccordingToEvent(e);
            return true;
        }
        
        var scroller = getFirstParentScroller(e);
        if (!scroller || !scroller.$meems_dragging) {
            scrollUpOrDownAccordingToEvent(e);
            return true;
        }
                
        var config = scroller.$meems_config,
            newPos = Events.Touch.getCursorPosition(e),
            offsetX = scroller.$meems_cursor_pos.x - newPos.x,
            offsetY = scroller.$meems_cursor_pos.y - newPos.y;
            
        if (scroller.$meems_drag_distance < config.minDistanceOfDrag) {
            scroller.$meems_drag_distance += offsetX * offsetX + offsetY * offsetY;
            if (e.preventDefault) {
                e.preventDefault();
            }
            return true;
        } else if (config.axisLock && scroller.$meems_locked_axis === undefined) {
            scroller.$meems_locked_axis = (offsetX * offsetX > offsetY * offsetY ? 'x' : 'y');
        }

        var posX, posY;
        
        if (config.scrollX && (scroller.$meems_locked_axis === 'x' || scroller.$meems_locked_axis === undefined)) {
            posX = scroller.$meems_old_pos.x - offsetX;
            
            if (!config.bouncing) {
                if (posX > 0) {
                    posX = 0;
                } else if (posX < -scroller.$meems_content_size.width + scroller.$meems$elm_size.width) {
                    posX = -scroller.$meems_content_size.width + scroller.$meems$elm_size.width;
                }
            }
            
            scroller.$meems_effective_drag_distance += offsetX * offsetX;
            //style.left = posX + "px";
            if (!config.hideScroller) {
                scroller.$meems_scrollbar_x.style.display = 'block';
            }
        }
        
        if (config.scrollY && (scroller.$meems_locked_axis === 'y' || scroller.$meems_locked_axis === undefined)) {
            posY = scroller.$meems_old_pos.y - offsetY;
            
            if (!config.bouncing) {
                if (posY > 0) {
                    posY = 0;
                } else if (posY < -scroller.$meems_content_size.height + scroller.$meems$elm_size.height) {
                    posY = -scroller.$meems_content_size.height + scroller.$meems$elm_size.height;
                }
            }
            
            scroller.$meems_effective_drag_distance += offsetY * offsetY;
            //style.top = posY + "px";
            if (!config.hideScroller) {
                scroller.$meems_scrollbar_y.style.display = 'block';
            }
        }
        
        setContentPos(scroller, posX, posY);
        
        scroller.$meems_cursor_last_pos = newPos;
        fastUpdateScrollbar(scroller, posX, posY);
        
        if (e.preventDefault) {
            e.preventDefault();
        }

        return true;
    }
    
    function onTouchEnd(e) {
        $mouseIsDown = false;

        var scroller = getFirstParentScroller(e);
        if (!scroller || !scroller.$meems_dragging) {
            return true;
        }
        
        --$scrollersDragging;
        scroller.$meems_dragging = false;
        
        var config = scroller.$meems_config;
        
        if (scroller.$meems_effective_drag_distance < config.minDistanceOfDrag) {
            return true;
        }
            
        var newPos = scroller.$meems_cursor_last_pos,
            time = Math.min(2.0, ((new Date()).getTime() - scroller.$meems_dragging_start) / 1000.0);
        
        var finalY, finalYPos, finalYPosTime,
            finalX, finalXPos, finalXPosTime;
        
        if (config.scrollY) {
            var scrollerHeight = scroller.$meems$elm_size.height,
                contentHeight = scroller.$meems_content_size.height;

            finalY = calculateFinalPositionAndTime(config, scroller.$meems_cursor_pos.y, newPos.y, scroller.$meems_old_pos.y, time, scrollerHeight, contentHeight);
            finalYPos = finalY[0];
            finalYPosTime = finalY[1];
            finalY = null;
        }
        
        if (config.scrollX) {
            var scrollerWidth = scroller.$meems$elm_size.width,
                contentWidth = scroller.$meems_content_size.width;
            
            finalX = calculateFinalPositionAndTime(config, scroller.$meems_cursor_pos.x, newPos.x, scroller.$meems_old_pos.x, time, scrollerWidth, contentWidth);
            finalXPos = finalX[0];
            finalXPosTime = finalX[1];
            finalX = null;
        }
        
        scrollAux(scroller, finalXPos, finalXPosTime, finalYPos, finalYPosTime);

        if (e.preventDefault) {
            e.preventDefault();
        }

        if (e.stopPropagation) {
            e.stopPropagation();
        }

        if (e.cancelBubble !== undefined) {
            e.cancelBubble = true;
        }

        return false;
    }
    
    function scrollAux(scroller, finalXPos, finalXPosTime, finalYPos, finalYPosTime) {
        var config = scroller.$meems_config,
            content = scroller.$meems_content,
            maxTime = Math.max(finalXPosTime || 0, finalYPosTime || 0),
            transitionRule = "all " + maxTime + "s " + config.timingFunction;

        if (maxTime > 0) {
            content.style[transitionName] = transitionRule;

            window.requestAnimationFrame(function () {
                setContentPos(scroller, finalXPos, finalYPos);

                touchEndScrollbarAnimation(scroller, maxTime);
                Utils.Fn.postPone(function () {
                    scroller.$meems_handler.fire("scroll:end", -(finalXPos || 0), -(finalYPos || 0));
                });
            });
        }
    }
    
    function createVerticalScrollBar(elm, config) {
        if (config.hideScroller) {
            return;
        }
        elm.$meems_scrollbar_y = document.createElement("div");
        elm.$meems_scrollbar_y.className = "ui-scroll-bar-y";
        elm.$meems_scrollbar_y.style.position = "absolute";
        elm.$meems_scrollbar_y.style.display = 'none';
        elm.appendChild(elm.$meems_scrollbar_y);
    }
    
    function createHorizontalScrollBar(elm, config) {
        if (config.hideScroller) {
            return;
        }
        elm.$meems_scrollbar_x = document.createElement("div");
        elm.$meems_scrollbar_x.className = "ui-scroll-bar-x";
        elm.$meems_scrollbar_x.style.position = "absolute";
        elm.$meems_scrollbar_x.style.display = 'none';
        elm.appendChild(elm.$meems_scrollbar_x);
    }
    
    function touchEndScrollbarAnimation(scroller, totalTime) {
        var content = scroller.$meems_content,
            scrollbarX = scroller.$meems_scrollbar_x,
            scrollbarY = scroller.$meems_scrollbar_y,
            totalMs = totalTime * 1000.0,
            start = (new Date()).getTime(), lastFrame,
            fadeOutDuration = scroller.$meems_config.fadeOutDuration * 1000.0,
            startOp, op,
            interval;
        
        scroller.$meems_scrolling_running_animation = true;

        function fadeOut() {
            var timestamp = (new Date()).getTime();
            op -= interval * (timestamp - lastFrame);

            if (scrollbarX) {
                scrollbarX.style.opacity = op;
            }
            
            if (scrollbarY) {
                scrollbarY.style.opacity = op;
            }
            
            if (scroller.$meems_scrolling_running_animation && timestamp - start < fadeOutDuration) {
                lastFrame = timestamp;
                window.requestAnimationFrame(fadeOut);
            } else {
                if (scrollbarX) {
                    scrollbarX.style.display = 'none';
                    scrollbarX.style.opacity = startOp;
                }

                if (scrollbarY) {
                    scrollbarY.style.display = 'none';
                    scrollbarY.style.opacity = startOp;
                }
                
                scroller.$meems_scrolling_running_animation = false;
            }
        }
        
        function req() {
            var timestamp = (new Date()).getTime();
            
            updateScrollbar(scroller, content);
            
            if (scroller.$meems_scrolling_running_animation && timestamp - start < totalMs) {
                window.requestAnimationFrame(req);
            } else {
                startOp =
                     (scrollbarX && document.defaultView.getComputedStyle(scrollbarX, null).opacity) ||
                     (scrollbarY && document.defaultView.getComputedStyle(scrollbarY, null).opacity) || 1.0;
                op = startOp;
                interval = startOp / fadeOutDuration;
                lastFrame = start = (new Date()).getTime();
                window.requestAnimationFrame(fadeOut);
            }
        }
        
        window.requestAnimationFrame(req);
    }

    var matrixPattern = /[\-\d\.]+, [\-\d\.]+, [\-\d\.]+, [\-\d\.]+, ([\-\d\.]+), ([\-\d\.]+)/;

    function updateScrollbar(scroller, content) {
        var config = scroller.$meems_config;
        
        if (config.hideScroller) {
            return;
        }

        var animPos = (function () {
            var style = document.defaultView.getComputedStyle(content, null), m;

            if ((m = style[transformNameJs].match(matrixPattern)) !== null) {
                return {
                    left : parseFloat(m[1]),
                    top: parseFloat(m[2])
                };
            } else {
                return {
                    left : scroller.$meems_content_size.left,
                    top: scroller.$meems_content_size.top
                };
            }
        }());

        if (config.scrollY) {
            var scrollbarY = scroller.$meems_scrollbar_y,
                scrollerHeight = scroller.$meems$elm_size.height,
                contentHeight = scroller.$meems_content_size.height,
                verticalBarY = (-animPos.top / contentHeight) * scrollerHeight;

            scrollbarY.style[transformName] = "translate3d(0,"+verticalBarY+"px,0)";
        }
        
        if (config.scrollX) {
            var scrollbarX = scroller.$meems_scrollbar_x,
                scrollerWidth = scroller.$meems$elm_size.width,
                contentWidth = scroller.$meems_content_size.width,
                verticalBarX = (-animPos.left / contentWidth) * scrollerWidth;

            scrollbarX.style[transformName] = "translate3d(" +  verticalBarX + "px,0,0)";
        }
    }

    function updateScrollbarsSize(scroller) {
        var config = scroller.$meems_config;

        if (config.hideScroller) {
            return;
        }

        if (config.scrollY) {
            var scrollerHeight = scroller.$meems$elm_size.height,
                contentHeight = scroller.$meems_content_size.height,
                verticalBarH = (Math.min(scrollerHeight, contentHeight) / contentHeight) * scrollerHeight;

            scroller.$meems_scrollbar_y.style.height = verticalBarH + "px";
        }

        if (config.scrollX) {
            var scrollbarX = scroller.$meems_scrollbar_x,
                scrollerWidth = scroller.$meems$elm_size.width,
                contentWidth = scroller.$meems_content_size.width,
                verticalBarW = (Math.min(scrollerWidth, contentWidth) / contentWidth) * scrollerWidth;

            scrollbarX.style.width = verticalBarW + "px";
        }
    }

    function fastUpdateScrollbar(scroller, x, y) {
        var config = scroller.$meems_config;

        if (config.hideScroller) {
            return;
        }

        if (config.scrollY) {
            var scrollbarY = scroller.$meems_scrollbar_y,
                scrollerHeight = scroller.$meems$elm_size.height,
                contentHeight = scroller.$meems_content_size.height,
                verticalBarY = (-y / contentHeight) * scrollerHeight;

            //scrollbarY.style.top = verticalBarY + "px";
            scrollbarY.style[transformName] = "translate3d(0,"+verticalBarY+"px,0)";
        }

        if (config.scrollX) {
            var scrollbarX = scroller.$meems_scrollbar_x,
                scrollerWidth = scroller.$meems$elm_size.width,
                contentWidth = scroller.$meems_content_size.width,
                verticalBarX = (-x / contentWidth) * scrollerWidth;

            //scrollbarX.style.left = verticalBarX + "px";
            scrollbarX.style[transformName] = "translate3d(" +  verticalBarX + "px,0,0)";
        }
    }
    
    var setContentPos = function (scroller, left, top) {
        var l = left === undefined ? scroller.$meems_content_size.left || 0 : left || 0,
            t = top === undefined ? scroller.$meems_content_size.top || 0 : top || 0;

        scroller.$meems_content.style[transformName] = "translate3d(" +  l + "px," + t + "px, 0)";
        scroller.$meems_content_size.left = l;
        scroller.$meems_content_size.top = t;
    };
    
    var getObjectDimensions = function (el) {
        return {
            left: el.offsetLeft,
            top: el.offsetTop,
            width: el.offsetWidth,
            height: el.offsetHeight
        };
    };

    /**
     * @class Scroll
     * @constructor
     */
    function Scroll(elm, config) {
        Events.Handler.apply(this, arguments); // super
        
        config = config || {};
        config.friction = config.friction || 0.2;
        config.totalMaxTime = config.totalMaxTime || 1;
        config.paging = config.paging === true;
        config.snap = config.snap || 0;
        config.scrollY = config.scrollY !== false;
        config.scrollX =  config.scrollX === true;
        config.timingFunction = config.timingFunction || "ease-out";
        config.fadeOutDuration = config.fadeOutDuration || 1;
        config.bouncing = config.bouncing !== false;
        config.minDistanceOfDrag = config.minDistanceOfDrag || 10;
        config.axisLock = config.axisLock !== false;
        config.disableTouchEvents = config.disableTouchEvents === true;
        config.hideScroller = config.hideScroller === true;
        
        elm.$meems_content = elm.children[0];
        registerHandlers(elm, config);
        
        if (config.scrollY) {
            createVerticalScrollBar(elm, config);
        }
        
        if (config.scrollX) {
            createHorizontalScrollBar(elm, config);
        }
        
        this.$elm = elm;
        this.$elm.$meems_handler = this;
        this.$elm.$meems$elm_size = getObjectDimensions(this.$elm);
        this.$elm.$meems_content_size = getObjectDimensions(this.$elm.$meems_content);
        
        activeScrollers.push(this);
        
        return this;
    }

    /**
     * Updates all scroller that were ever created and are still active.
     * @method updateAll
     * @static
     */
    Scroll.updateAll = function () {
        var scroller;
        for (var i = 0, ln = activeScrollers.length; i < ln; ++i) {
            scroller = activeScrollers[i];
            scroller.update();
            //scroller.scrollTo(scroller.$elm.$meems_content_size.left, scroller.$elm.$meems_content_size.top);
        }
    };
    
    Scroll.extend(Events.Handler, {
        /**
         * Update the size of the scroller, should be called after a layout change.
         *
         * @method update
         */
        update : function () {
            this.$elm.$meems$elm_size = getObjectDimensions(this.$elm);
            this.$elm.$meems_content_size = getObjectDimensions(this.$elm.$meems_content);
            updateScrollbar(this.$elm, this.$elm.$meems_content);
        },

        /**
         * Destroy this scroller instance.
         *
         * @method destroy
         */
        destroy : function () {
            activeScrollers.splice(activeScrollers.indexOf(this), 0);
            removeHandlers(this.$elm, this.$meems_config);
        },

        /**
         * Scroll to the given position, with animation.
         *
         * @method scrollTo
         * @param {Number} x What x coordinate should be at the left-top corner after scrolling.
         * @param {Number} [y] What y coordinate should be at the left-top corner after scrolling.
         * @param {Number} [duration] How long the animation should last.
         */
        scrollTo : function (x, y, duration) {
            duration = duration || 0.25;
            
            if (!this.$elm.$meems_config.hideScroller) {
                if (this.$elm.$meems_config.scrollY) {
                    this.$elm.$meems_scrollbar_y.style.display = 'block';
                }
                
                if (this.$elm.$meems_config.scrollX) {
                    this.$elm.$meems_scrollbar_x.style.display = 'block';
                }
            }
            
            scrollAux(this.$elm, -x, duration, -y, duration);
        }
    });

    Events.Dom.on(document, Events.Touch.touchStartEventName, onDocumentTouchStart);
    Events.Dom.on(document, Events.Touch.touchEndEventName, onDocumentTouchEnd);

    return Scroll;
});

/*global define*/
define('ui/page',["meems-utils", "meems-scroll", "./widget"],
/**
 * A page component.
 * Exposes several facets: header, content, footer.
 *
 * @module meems-ui
 * @submodule page
 * @requires meems-utils
 * @requires meems-scroll
 */
function (Utils, Scroll, Widget) {
    

    /**
     * @class Page
     * @constructor
     * @extends Widget
     */
    function Page() {
        Widget.apply(this, arguments);
        
        this.facet("header", null);
        this.facet("content", null);
        this.facet("footer", null);
        this.attr("enableScroll", false);
        
        this.$contentWrapper = null;
        this.$scroller = null;
        
        return this;
    }
    
    Page.extend(Widget, {
        /**
         * Getter for the Scroll component associated with this page.
         *
         * @method scroller
         * @return {Scroll} The scroller.
         */
        scroller : function () {
            return this.$scroller;
        },

        update : function (structureOnly) {
            if (!this.el()) {
                this.el(document.createElement("div"));
                this.el().className = "ui-page";
            }
            
            if (this.facet("header")) {
                this.facet("header").update(structureOnly);
                
                if (this.facet("header").el().parentNode !== this.el()) {
                    this.el().appendChild(this.facet("header").el());
                }
            }
            
            if (this.facet("content")) {
                this.facet("content").update(structureOnly);
                
                if (!this.facet("content").el().parentNode || this.facet("content").el().parentNode !== this.$contentWrapper) {
                    this.$contentWrapper = document.createElement("div");
                    this.$contentWrapper.className = "ui-content";
                    this.$contentWrapper.appendChild(this.facet("content").el());
                    this.el().appendChild(this.$contentWrapper);
                }
            }
            
            if (this.facet("footer")) {
                this.facet("footer").update(structureOnly);
                
                if (this.facet("footer").el().parentNode !== this.el()) {
                    this.el().appendChild(this.facet("footer").el());
                }
            }
            
            if (this.facet("content")) {
                if (this.facet("header")) {
                    Utils.Dom.removeClass(this.$contentWrapper, "ui-header-off");
                } else {
                    Utils.Dom.addClass(this.$contentWrapper, "ui-header-off");
                }
                
                if (this.facet("footer")) {
                    Utils.Dom.removeClass(this.$contentWrapper, "ui-footer-off");
                } else {
                    Utils.Dom.addClass(this.$contentWrapper, "ui-footer-off");
                }
            }

            if (this.attr("enableScroll") === true && !this.$scroller) {
                this.$scroller = new Scroll(this.$contentWrapper, {
                    scrollX: false,
                    scrollY: true,
                    disableTouchEvents : false,
                    hideScroller : false
                });
            }

            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return Page;
});

(function(root,factory){if(typeof exports==="object"&&exports){module.exports=factory}else if(typeof define==="function"&&define.amd){define('mustache',factory)}else{root.Mustache=factory}})(this,function(){var exports={};exports.name="mustache.js";exports.version="0.7.2";exports.tags=["{{","}}"];exports.Scanner=Scanner;exports.Context=Context;exports.Writer=Writer;var whiteRe=/\s*/;var spaceRe=/\s+/;var nonSpaceRe=/\S/;var eqRe=/\s*=/;var curlyRe=/\s*\}/;var tagRe=/#|\^|\/|>|\{|&|=|!/;function testRe(re,string){return RegExp.prototype.test.call(re,string)}function isWhitespace(string){return!testRe(nonSpaceRe,string)}var isArray=Array.isArray||function(obj){return Object.prototype.toString.call(obj)==="[object Array]"};function escapeRe(string){return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")}var entityMap={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;"};function escapeHtml(string){return String(string).replace(/[&<>"'\/]/g,function(s){return entityMap[s]})}exports.escape=escapeHtml;function Scanner(string){this.string=string;this.tail=string;this.pos=0}Scanner.prototype.eos=function(){return this.tail===""};Scanner.prototype.scan=function(re){var match=this.tail.match(re);if(match&&match.index===0){this.tail=this.tail.substring(match[0].length);this.pos+=match[0].length;return match[0]}return""};Scanner.prototype.scanUntil=function(re){var match,pos=this.tail.search(re);switch(pos){case-1:match=this.tail;this.pos+=this.tail.length;this.tail="";break;case 0:match="";break;default:match=this.tail.substring(0,pos);this.tail=this.tail.substring(pos);this.pos+=pos}return match};function Context(view,parent){this.view=view;this.parent=parent;this.clearCache()}Context.make=function(view){return view instanceof Context?view:new Context(view)};Context.prototype.clearCache=function(){this._cache={}};Context.prototype.push=function(view){return new Context(view,this)};Context.prototype.lookup=function(name){var value=this._cache[name];if(!value){if(name==="."){value=this.view}else{var context=this;while(context){if(name.indexOf(".")>0){var names=name.split("."),i=0;value=context.view;while(value&&i<names.length){value=value[names[i++]]}}else{value=context.view[name]}if(value!=null){break}context=context.parent}}this._cache[name]=value}if(typeof value==="function"){value=value.call(this.view)}return value};function Writer(){this.clearCache()}Writer.prototype.clearCache=function(){this._cache={};this._partialCache={}};Writer.prototype.compile=function(template,tags){var fn=this._cache[template];if(!fn){var tokens=exports.parse(template,tags);fn=this._cache[template]=this.compileTokens(tokens,template)}return fn};Writer.prototype.compilePartial=function(name,template,tags){var fn=this.compile(template,tags);this._partialCache[name]=fn;return fn};Writer.prototype.compileTokens=function(tokens,template){var fn=compileTokens(tokens);var self=this;return function(view,partials){if(partials){if(typeof partials==="function"){self._loadPartial=partials}else{for(var name in partials){self.compilePartial(name,partials[name])}}}return fn(self,Context.make(view),template)}};Writer.prototype.render=function(template,view,partials){return this.compile(template)(view,partials)};Writer.prototype._section=function(name,context,text,callback){var value=context.lookup(name);switch(typeof value){case"object":if(isArray(value)){var buffer="";for(var i=0,len=value.length;i<len;++i){buffer+=callback(this,context.push(value[i]))}return buffer}return value?callback(this,context.push(value)):"";case"function":var self=this;var scopedRender=function(template){return self.render(template,context)};var result=value.call(context.view,text,scopedRender);return result!=null?result:"";default:if(value){return callback(this,context)}}return""};Writer.prototype._inverted=function(name,context,callback){var value=context.lookup(name);if(!value||isArray(value)&&value.length===0){return callback(this,context)}return""};Writer.prototype._partial=function(name,context){if(!(name in this._partialCache)&&this._loadPartial){this.compilePartial(name,this._loadPartial(name))}var fn=this._partialCache[name];return fn?fn(context):""};Writer.prototype._name=function(name,context){var value=context.lookup(name);if(typeof value==="function"){value=value.call(context.view)}return value==null?"":String(value)};Writer.prototype._escaped=function(name,context){return exports.escape(this._name(name,context))};function compileTokens(tokens){var subRenders={};function subRender(i,tokens,template){if(!subRenders[i]){var fn=compileTokens(tokens);subRenders[i]=function(writer,context){return fn(writer,context,template)}}return subRenders[i]}return function(writer,context,template){var buffer="";var token,sectionText;for(var i=0,len=tokens.length;i<len;++i){token=tokens[i];switch(token[0]){case"#":sectionText=template.slice(token[3],token[5]);buffer+=writer._section(token[1],context,sectionText,subRender(i,token[4],template));break;case"^":buffer+=writer._inverted(token[1],context,subRender(i,token[4],template));break;case">":buffer+=writer._partial(token[1],context);break;case"&":buffer+=writer._name(token[1],context);break;case"name":buffer+=writer._escaped(token[1],context);break;case"text":buffer+=token[1];break}}return buffer}}function nestTokens(tokens){var tree=[];var collector=tree;var sections=[];var token;for(var i=0,len=tokens.length;i<len;++i){token=tokens[i];switch(token[0]){case"#":case"^":sections.push(token);collector.push(token);collector=token[4]=[];break;case"/":var section=sections.pop();section[5]=token[2];collector=sections.length>0?sections[sections.length-1][4]:tree;break;default:collector.push(token)}}return tree}function squashTokens(tokens){var squashedTokens=[];var token,lastToken;for(var i=0,len=tokens.length;i<len;++i){token=tokens[i];if(token[0]==="text"&&lastToken&&lastToken[0]==="text"){lastToken[1]+=token[1];lastToken[3]=token[3]}else{lastToken=token;squashedTokens.push(token)}}return squashedTokens}function escapeTags(tags){return[new RegExp(escapeRe(tags[0])+"\\s*"),new RegExp("\\s*"+escapeRe(tags[1]))]}exports.parse=function(template,tags){template=template||"";tags=tags||exports.tags;if(typeof tags==="string")tags=tags.split(spaceRe);if(tags.length!==2){throw new Error("Invalid tags: "+tags.join(", "))}var tagRes=escapeTags(tags);var scanner=new Scanner(template);var sections=[];var tokens=[];var spaces=[];var hasTag=false;var nonSpace=false;function stripSpace(){if(hasTag&&!nonSpace){while(spaces.length){tokens.splice(spaces.pop(),1)}}else{spaces=[]}hasTag=false;nonSpace=false}var start,type,value,chr;while(!scanner.eos()){start=scanner.pos;value=scanner.scanUntil(tagRes[0]);if(value){for(var i=0,len=value.length;i<len;++i){chr=value.charAt(i);if(isWhitespace(chr)){spaces.push(tokens.length)}else{nonSpace=true}tokens.push(["text",chr,start,start+1]);start+=1;if(chr==="\n"){stripSpace()}}}start=scanner.pos;if(!scanner.scan(tagRes[0])){break}hasTag=true;type=scanner.scan(tagRe)||"name";scanner.scan(whiteRe);if(type==="="){value=scanner.scanUntil(eqRe);scanner.scan(eqRe);scanner.scanUntil(tagRes[1])}else if(type==="{"){var closeRe=new RegExp("\\s*"+escapeRe("}"+tags[1]));value=scanner.scanUntil(closeRe);scanner.scan(curlyRe);scanner.scanUntil(tagRes[1]);type="&"}else{value=scanner.scanUntil(tagRes[1])}if(!scanner.scan(tagRes[1])){throw new Error("Unclosed tag at "+scanner.pos)}if(type==="/"){if(sections.length===0){throw new Error('Unopened section "'+value+'" at '+start)}var section=sections.pop();if(section[1]!==value){throw new Error('Unclosed section "'+section[1]+'" at '+start)}}var token=[type,value,start,scanner.pos];tokens.push(token);if(type==="#"||type==="^"){sections.push(token)}else if(type==="name"||type==="{"||type==="&"){nonSpace=true}else if(type==="="){tags=value.split(spaceRe);if(tags.length!==2){throw new Error("Invalid tags at "+start+": "+tags.join(", "))}tagRes=escapeTags(tags)}}var section=sections.pop();if(section){throw new Error('Unclosed section "'+section[1]+'" at '+scanner.pos)}return nestTokens(squashTokens(tokens))};var _writer=new Writer;exports.clearCache=function(){return _writer.clearCache()};exports.compile=function(template,tags){return _writer.compile(template,tags)};exports.compilePartial=function(name,template,tags){return _writer.compilePartial(name,template,tags)};exports.compileTokens=function(tokens,template){return _writer.compileTokens(tokens,template)};exports.render=function(template,view,partials){return _writer.render(template,view,partials)};exports.to_html=function(template,view,partials,send){var result=exports.render(template,view,partials);if(typeof send==="function"){send(result)}else{return result}};return exports}());
/*global define*/
/**
 * Component that can render HTML using Mustache templates.
 * Define the template using the 'html' attribute and bind data using the 'data' attribute.
 * If any of those are observable attributes, the component will be updated when any of them
 * changes.
 *
 * @module meems-ui
 * @submodule html
 * @requires mustache
 * @requires meems-utils
 */
define('ui/html',["meems-utils", "./widget", "mustache"], function (Utils, Widget, Mustache) {
    

    /**
     * @class Html
     * @constructor
     * @extends Widget
     */
    function Html() {
        this._compiledTemplate = Mustache.compile("");

        Widget.apply(this, arguments);
        return this;
    }
    
    Html.extend(Widget, {
        attr : function (attrName, val) {
            if (val !== undefined && attrName === 'html') {
                this._compiledTemplate = Mustache.compile(val || "");
            }

            return Widget.prototype.attr.apply(this, arguments); // super
        },

        partialUpdate : function (attrName) {
            if ((attrName === 'html' || attrName === 'data') && this.el()) {
                Utils.Dom.setHtml(this.el(), this._compiledTemplate(this.attr("data")));
            }
        },

        update : function () {
            if (!this.el()) {
                this.el(document.createElement("div"));
                Utils.Dom.addClass(this.el(), "ui-html");
            }

            Utils.Dom.setHtml(this.el(), this._compiledTemplate(this.attr("data")));
            
            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return Html;
});

/*global define*/
/**
 * A component that represents a button.
 *
 * @module meems-ui
 * @submodule button
 * @requires meems-utils
 */
define('ui/button',["meems-utils", "./widget"], function (Utils, Widget) {
    

    /**
     * @class Button
     * @constructor
     * @extends Widget
     */
    function Button() {
        Widget.apply(this, arguments);
        this.$iconEl = null;
        this.$titleEl = null;
        return this;
    }
    
    Button.extend(Widget, {
        attr : function (name, val) {
            var oldStyle = name === 'style' ? Widget.prototype.attr.call(this, name) : null;
            var ret = Widget.prototype.attr.apply(this, arguments);

            if (name === 'style' && val !== undefined && this.el()) {
                if (oldStyle) {
                    Utils.Dom.removeClass(this.el(), "ui-button-" + oldStyle);
                } else {
                    Utils.Dom.removeClass(this.el(), "ui-button-normal");
                }
                
                if (val) {
                    Utils.Dom.addClass(this.el(), "ui-button-" + val);
                } else {
                    Utils.Dom.addClass(this.el(), "ui-button-normal");
                }
            }
            
            return ret;
        },

        partialUpdate : function (attrName, oldValue, newValue) {
            if (attrName === 'title' && this.$titleEl) {
                Utils.Dom.setHtml(this.$titleEl, this.attr("title"));
                this.$iconEl.setAttribute("title", this.attr("title"));
                Utils.Dom.applyChanges();
            } else if (attrName === 'style' && this.el()) {
                if (oldValue) {
                    Utils.Dom.removeClass(this.el(), "ui-button-" + oldValue);
                } else {
                    Utils.Dom.removeClass(this.el(), "ui-button-normal");
                }

                if (newValue) {
                    Utils.Dom.addClass(this.el(), "ui-button-" + newValue);
                } else {
                    Utils.Dom.addClass(this.el(), "ui-button-normal");
                }
            } else if (attrName === 'icon' && this.$iconEl) {
                Utils.Dom.setClass(this.$iconEl, (newValue ? "ui-icon ui-icon-" + newValue : "ui-no-icon")
                    + (this.attr("disabled") === true ? " ui-disabled" : ""));
            }
        },

        update : function () {
            if (!this.el()) {
                this.el(document.createElement("div"));
                
                this.$iconEl = document.createElement("div");
                this.$iconEl.className = "ui-icon";
                this.$iconEl.setAttribute("title", this.attr("title") || "");
                this.el().appendChild(this.$iconEl);
                
                this.$titleEl = document.createElement("div");
                this.$titleEl.className = "ui-title";
                this.el().appendChild(this.$titleEl);
                
                Utils.Dom.addClass(this.el(), "ui-button");
            }
            
            Utils.Dom.setClass(this.$iconEl, (this.attr("icon") ? "ui-icon ui-icon-" + this.attr("icon") : "ui-no-icon")
                                   + (this.attr("disabled") === true ? " ui-disabled" : ""));
            Utils.Dom.setHtml(this.$titleEl, this.attr("title"));
            
            this.attr("style", this.attr("style") !== undefined ? this.attr("style") : null);
            
            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return Button;
});

/*global define*/
/**
 * Pops up a menu with items.
 *
 * @module meems-ui
 * @submodule popupmenu
 * @requires meems-utils meems-events widget
 */
define('ui/popup_menu',["meems-utils", "meems-events", "./widget"], function (Utils, Events, Widget) {
    

    /**
     * @class PopupMenu
     * @constructor
     * @extends Widget
     */
    function PopupMenu() {
        /**
         * @property $ul
         * @private
         * @type {HTMLElement}
         */
        this.$ul = null;
        /**
         * @property $items
         * @private
         * @type {Observable|Array}
         */
        this.$items = [];

        Widget.apply(this, arguments);
        return this;
    }

    var updateListItems = function (oldItems, newItems) {
        this.$ul.innerHTML = "";

        for (var i = 0, len = newItems.length; i < len; ++i) {
            var li = document.createElement("li");
            li.innerHTML = newItems[i].text;
            li.className = "ui-popup-item";
            this.$ul.appendChild(li);
        }

        if (this.$ul.childNodes.length > 0) {
            this.$ul.childNodes[0].className += " ui-popup-item-first";
            this.$ul.childNodes[this.$ul.childNodes.length - 1].className += " ui-popup-item-last";
        }
    };

    var visiblePopups = [];
    var dismissHandlerInstalled = false;
    var dismissPopups = function (e) {
        var target = e.target;

        while (target && ((target.className && target.className.indexOf("ui-popup-item") === -1) || !target.className)) {
            target = target.parentNode;
        }

        if (target) {
            var popupEl = target.parentNode.parentNode,
                pos = Utils.Array.indexOfByProp(visiblePopups, "$el", popupEl);

            if (pos > -1) {
                var masterPopup = visiblePopups[pos],
                    itemIndex = Array.prototype.indexOf.call(target.parentNode.childNodes, target),
                    item = masterPopup.$items[itemIndex],
                    action = item.action;

                if (action) {
                    action.call(masterPopup, item);
                }
            }
        }

        var popup;
        for (var i = 0, len = visiblePopups.length; i < len; ++i) {
            popup = visiblePopups[i];

            if (popup.el() && popup.el().parentNode !== null) {
                if (popup.$lastShow && ((new Date()).getTime() - popup.$lastShow.getTime()) > 500) {
                    document.body.removeChild(popup.el());
                    popup.$lastShow = null;
                    visiblePopups.splice(i, 0);
                    --len; --i;
                }
            }
        }
    };

    PopupMenu.extend(Widget, {
        /**
         * Getter and setter for the value of the field.
         *
         * @method value
         * @param {observable.Observable|String} [val] The new value.
         * @return {TextField|observable,Observable|String} `this` if called as a setter,
         * the current value otherwise.
         */
        items : function (val) {
            if (val === undefined) {
                return this.$items;
            } else {
                updateListItems.call(this, this.$items, val);
                this.$items = val;
                return this;
            }
        },

        isVisible : function () {
            return this.el().parentNode !== null;
        },

        hide : function () {
            if (this.el().parentNode !== null) {
                document.body.removeChild(this.el());
                this.$lastShow = null;
                Utils.Array.remove(visiblePopups, this);
            }

            return this;
        },

        show : function (cmp, pos, offsetX, offsetY) {
            var cmpDomPos = Utils.Dom.getRect(cmp),
                x = cmpDomPos.x,
                y = cmpDomPos.y,
                xCoord = 'left',
                yCoord = 'top';

            if (pos.indexOf('below') > -1) {
                y = cmpDomPos.y + cmpDomPos.height;
            }

            if (pos.indexOf('right') > -1) {
                x = document.body.clientWidth - cmpDomPos.x - cmpDomPos.width;
                xCoord = 'right';
            }

            x += offsetX || 0;
            y += offsetY || 0;

            this.el().style[xCoord] = x + 'px';
            this.el().style[yCoord] = y + 'px';

            document.body.appendChild(this.el());
            this.$lastShow = new Date();

            visiblePopups.push(this);

            return this;
        },

        update : function () {
            if (!this.el()) {
                this.el(document.createElement("div"));
                this.$ul = document.createElement("ul");
                this.el().appendChild(this.$ul);
                this.el().className = "ui-popup-menu";

                if (typeof (this.$items) === 'function') {
                    if ("subscribe" in this.$items) {
                        this.$items.subscribe(Utils.Fn.bind(updateListItems, this));
                    }
                }

                if (!dismissHandlerInstalled) {
                    Events.Dom.on(document, Events.Touch.touchEndEventName, dismissPopups);
                    dismissHandlerInstalled = true;
                }
            }

            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return PopupMenu;
});

/*global define*/
/**
 * A component that represents a button group.
 *
 * @module meems-ui
 * @submodule buttongroup
 * @requires meems-utils widget button
 */
define('ui/button_group',["meems-utils", "./widget", "./button", "./popup_menu"], function (Utils, Widget, Button, PopupMenu) {
    

    /**
     * @class ButtonGroup
     * @constructor
     * @extends Widget
     */
    function ButtonGroup() {
        Widget.apply(this, arguments);
        this.$buttons = [];
        this.$overflow = null;
        this.$popupMenu = null;
        return this;
    }

    /**
     * Triggered when the button is clicked.
     *
     * @event button:pressed
     * @param {String} eventName The name of the event.
     * @param {Event} e The event element.
     */
    // Called when a button is clicked.
    var onButtonTapped = function (eventName, e) {
        var target = e.target;

        while (target && ((target.className && target.className.indexOf("ui-button") === -1) || !target.className)) {
            target = target.parentNode;
        }
        
        if (target) {
            if (target === this.$overflow.el()) {
                showOverflowMenu.call(this);
            } else {
                var index = Utils.Array.indexOfByProp(this.$buttons, "$el", target);
                if (index > -1) {
                    this.fire("button:pressed", this.$buttons[index]);
                }
            }
        }
    };

    var updateButtons = function(structureOnly) {
        if (this.el()) {
            var btn,
                el = this.el(),
                stretch = (this.attr("stretch") === true),
                buttonSize = this.$buttons.length > 0 ? 100.0 / this.$buttons.length : 0,
                selected = this.attr("selected") !== undefined ? this.attr("selected") : -1,
                totalButtonsToShow = Math.min(this.attr("maxButtons") || 9999, this.$buttons.length);

            if (totalButtonsToShow < this.$buttons.length) {
                --totalButtonsToShow; // take out the overflow button
            }

            if (this.$overflow.el().parentNode === el) {
                el.removeChild(this.$overflow.el());
            }

            for (var i = 0; i < totalButtonsToShow; ++i) {
                btn = this.$buttons[i];

                btn.update(structureOnly);

                if (btn.el().parentNode !== el) {
                    el.appendChild(btn.el());
                    btn.on("dom:" + (Utils.Dom.supportsTouch() ? 'touchstart' : 'click'), Utils.Fn.bind(onButtonTapped, this));
                }

                if (stretch) {
                    btn.el().style.width = buttonSize + "%";
                } else {
                    btn.el().style.width = "";
                }

                if (selected === i) {
                    Utils.Dom.addClass(btn.el(), "ui-selected");
                } else {
                    Utils.Dom.removeClass(btn.el(), "ui-selected");
                }
            }

            for (var i = totalButtonsToShow; i < this.$buttons.length; ++i) {
                btn = this.$buttons[i];
                if (btn.el() && btn.el().parentNode === el) {
                    el.removeChild(btn.el());
                }
            }

            if (totalButtonsToShow !== this.$buttons.length) {
                // Add overflow button.
                if (this.$overflow.el().parentNode !== el) {
                    el.appendChild(this.$overflow.el());
                }
            } else {
                // Remove overflow button.
                if (this.$overflow.el().parentNode === el) {
                    el.removeChild(this.$overflow.el());
                }
            }
        }
    };

    var showOverflowMenu = function () {
        if (this.$popupMenu.isVisible()) {
            this.$popupMenu.hide();
            return;
        }

        var totalButtonsToShow = Math.min(this.attr("maxButtons") || 9999, this.$buttons.length);

        if (totalButtonsToShow < this.$buttons.length) {
            --totalButtonsToShow; // take out the overflow button
        }

        var btn, menuitems = [];
        for (var i = totalButtonsToShow, len = this.$buttons.length; i < len; ++i) {
            btn = this.$buttons[i];
            menuitems.push({
                text : btn.attr('title'),
                action : (function (self, b) {
                    return function () {
                        self.fire("button:pressed", b);
                    };
                })(this, btn)
            });
        }

        this.$popupMenu.items(menuitems);
        this.$popupMenu.show(this.$overflow.el(), 'below-right-aligned', 0, 5);
    };
    
    ButtonGroup.extend(Widget, {
        /**
         * Adds a new button to the group.
         *
         * @method addButton
         * @param {Button} btn The new button
         * @return {ButtonGroup} return this to allow chaining.
         */
        addButton : function (btn) {
            this.$buttons.push(btn);
            return this;
        },

        /**
         * Getter and setter for all the buttons in this group.
         *
         * @method buttons
         * @param {Button[]} [newButtons] New array of buttons
         * @return {ButtonGroup|Button[]} return this if used as a setter or the buttons if used as getter.
         */
        buttons : function (newButtons) {
            if (newButtons === undefined) {
                return this.$buttons;
            } else {
                if (this.$buttons && this.$buttons.length > 0) {
                    var btn, i;
                    
                    for (i = 0; i < this.$buttons.length; ++i) {
                        btn = this.$buttons[i];
                        if (btn.el() && btn.el().parentNode === this.el()) {
                            this.el().removeChild(btn.el());
                        }
                    }
                }

                this.$buttons = newButtons;

                updateButtons.call(this);

                return this;
            }
        },

        update : function (structureOnly) {
            if (!this.el()) {
                this.el(document.createElement("div"));
                Utils.Dom.addClass(this.el(), "ui-button-group");
                this.$overflow = (new Button()).attr('icon', 'overflow').attr('title', 'More');
                this.$overflow.update();
                this.$overflow.on("dom:" + (Utils.Dom.supportsTouch() ? 'touchstart' : 'click'), Utils.Fn.bind(onButtonTapped, this));
                this.$popupMenu = new PopupMenu();
                this.$popupMenu.update();
            }

            updateButtons.call(this, structureOnly);
            
            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return ButtonGroup;
});

/*global define*/
/**
 * List component that will render based on templates.
 * Supports header items for grouping.
 *
 * @module meems-ui
 * @submodule list
 * @requires meems-utils
 * @requires meems-events
 * @requires listitem
 * @requires html
 */
define('ui/list',["meems-utils", "meems-events", "./widget", "./html"], function (Utils, Events, Widget, Html) {
    

    /**
     * Called when the order button of an item is pressed.
     *
     * @method onStartOrdering
     * @private
     * @param {Event} e The associated mouse event.
     */
    var onStartOrdering = function (e) {
        if (this.$dragging) {
            return;
        }

        var el = this.el(),
            parent = this.parent(),
            parentEl = parent.el(),
            placeHolder = parent.$placeHolder;

        this.$dragging = true;

        Events.Dom.on(document, Events.Touch.touchMoveEventName, this.$onItemMoved);
        Events.Dom.on(document, Events.Touch.touchEndEventName, this.$onEndOrdering);

        this.$elementStartPosition = Utils.Dom.getAbsolutePosition(el);

        el.style.top = this.$elementStartPosition.y + "px";

        var elDimensions = Utils.Dom.getDimensions(el);
        el.style.width = elDimensions.width + "px";
        el.style.height = elDimensions.height + "px";
        placeHolder.className = el.className;
        placeHolder.style.width = elDimensions.width + "px";
        placeHolder.style.height = elDimensions.height + "px";

        this.$cursorStartPosition = Events.Touch.getCursorPosition(e);
        this.$elementStartPosition = Utils.Dom.getAbsolutePosition(el);

        Utils.Dom.addClass(el, "ui-list-item-drag");
        Utils.Dom.applyChanges();

        parentEl.insertBefore(placeHolder, el);

        return Events.Dom.cancelEvent(e);
    };

    /**
     * Called when the item is moved.
     *
     * @method onItemMoved
     * @private
     * @param {Event} e The associated mouse event.
     */
    var onItemMoved = function (e) {
        if (!this.$dragging) {
            return;
        }

        var el = this.el(),
            parent = this.parent(),
            parentEl = parent.el(),
            placeHolder = parent.$placeHolder,
            pos = Events.Touch.getCursorPosition(e),
            listItems = parentEl.children,
            bestItem = null,
            elHeight,
            item;

        pos.y += this.$elementStartPosition.y - this.$cursorStartPosition.y;
        el.style.top = pos.y + "px";
        var yPos = pos.y + el.offsetHeight / 2;

        for (var i = 0, ln = listItems.length; i < ln; ++i) {
            item = listItems[i];

            if (item !== el) {
                elHeight = item.offsetHeight;

                if (elHeight / 2 >= yPos) {
                    bestItem = item;
                    break;
                } else {
                    yPos -= elHeight;
                }
            }
        }

        if (bestItem === placeHolder) {
            return Events.Dom.cancelEvent(e);
        } else if (bestItem) {
            parentEl.insertBefore(placeHolder, bestItem);
        } else {
            parentEl.appendChild(placeHolder);
        }

        //return Events.Dom.cancelEvent(e);
    };

    /**
     * Called when the order button of an item is released.
     *
     * @method onEndOrdering
     * @private
     * @param {Event} e The associated mouse event.
     */
    var onEndOrdering = function (e) {
        if (!this.$dragging) {
            return;
        }

        var el = this.el(),
            parent = this.parent(),
            parentEl = parent.el(),
            placeHolder = parent.$placeHolder;

        Utils.Dom.removeClass(el, "ui-list-item-drag");
        el.style.top = "";
        el.style.width = "";
        el.style.height = "";

        Events.Dom.off(document, Events.Touch.touchMoveEventName, this.$onItemMoved);
        Events.Dom.off(document, Events.Touch.touchEndEventName, this.$onEndOrdering);

        Utils.Dom.applyChanges();

        parentEl.replaceChild(el, placeHolder);

        //noinspection JSValidateTypes
        var startPos = parent.$generatedItems.indexOf(this),
            endPos = Array.prototype.indexOf.call(parentEl.children, el);

        Utils.Array.moveElement(parent.$generatedItems, startPos, endPos);

        var items = parent.items();
        items = typeof(items) === 'function' ? items() : items;
        Utils.Array.moveElement(items, startPos, endPos);

        if (typeof(parent.items().notify) === 'function') {
            parent.items().notify(items, items);
        }

        this.$dragging = false;

        updateHeaderClasses.call(parent);

        return Events.Dom.cancelEvent(e);
    };

    /**
     * Internal class that holds a single item.
     *
     * @class ListItem
     * @private
     * @constructor
     * @extends Widget
     */
    function ListItem() {
        Widget.apply(this, arguments);
        this.$header = false;
        this.$table = null;
        this.$leftFacet = null;
        this.$rightFacet = null;
        this.$middleFacet = null;
        this.$orderButton = null;

        this.$dragging = false;
        this.$cursorStartPosition = null;
        this.$elementStartPosition = null;

        this.facet("item", null);

        this.$onItemMoved = Utils.Fn.bind(onItemMoved, this);
        this.$onEndOrdering = Utils.Fn.bind(onEndOrdering, this);

        return this;
    }

    ListItem.extend(Widget, {
        /**
         * Getter and setter for indicating if the item is a header.
         *
         * @method header
         * @param {boolean} [val] The new value for the property.
         * @chainable
         * @return {boolean|ListItem} `this` if called as a setter, the current value otherwise.
         */
        header : function (val) {
            if (val === undefined) {
                return this.$header;
            } else {
                this.$header = val;

                if (this.el()) {
                    if (this.$header) {
                        Utils.Dom.addClass(this.el(), "ui-list-header");
                        Utils.Dom.removeClass(this.el(), "ui-list-item");
                    } else {
                        Utils.Dom.addClass(this.el(), "ui-list-item");
                        Utils.Dom.removeClass(this.el(), "ui-list-header");
                    }
                }

                return this;
            }
        },

        update : function () {
            var showCheckbox = this.parent().attr('selectionMode') === 'multiple',
                showSorted = this.parent().attr('sortable') === true;

            if (!this.el()) {
                this.el(document.createElement("li"));

                if (showCheckbox || showSorted) {
                    this.$table = document.createElement("table");
                    this.$table.className = "ui-fill-width";

                    this.$leftFacet = document.createElement("td");
                    this.$middleFacet = document.createElement("td");
                    this.$middleFacet.className = "ui-fill-width";
                    this.$rightFacet = document.createElement("td");

                    var selectBox = document.createElement("input");
                    selectBox.setAttribute("type", "checkbox");
                    selectBox.className = "meems-scroll-skip";
                    Events.Dom.on(selectBox, 'change', Utils.Fn.bind(function() {
                        this.parent().fire("item:checked", this, selectBox.checked);
                    }, this));
                    this.$leftFacet.appendChild(selectBox);

                    this.$orderButton = document.createElement("div");
                    this.$orderButton.className = "ui-icon-order meems-scroll-skip";

                    Events.Dom.on(this.$orderButton, Events.Touch.touchStartEventName, Utils.Fn.bind(onStartOrdering, this));

                    this.$rightFacet.appendChild(this.$orderButton);

                    var tr = document.createElement("tr");
                    tr.appendChild(this.$leftFacet);
                    tr.appendChild(this.$middleFacet);
                    tr.appendChild(this.$rightFacet);
                    this.$table.appendChild(tr);

                    if (showCheckbox) {
                        this.$leftFacet.style.display = '';
                    } else {
                        this.$leftFacet.style.display = 'none';
                    }

                    if (showSorted) {
                        this.$rightFacet.style.display = '';
                    } else {
                        this.$rightFacet.style.display = 'none';
                    }

                    this.el().appendChild(this.$table);
                } else {
                    this.$middleFacet = this.el();
                }

                this.header(this.$header);
            }

            if (this.facet("item")) {
                this.facet("item").update();

                if (this.facet("item").el().parentNode !== this.$middleFacet) {
                    this.$middleFacet.appendChild(this.facet("item").el());
                }
            }

            Widget.prototype.update.apply(this, arguments); //super
        }
    });

    /**
     * @class List
     * @constructor
     * @extends Widget
     */
    function List() {
        Widget.apply(this, arguments);
        /**
         * @property $generatedItems
         * @private
         * @type {ListItem[]}
         */
        this.$generatedItems = [];
        /**
         * @property $items
         * @private
         * @type {observable.Observable|Array}
         */
        this.$items = [];
        /**
         * @property $template
         * @private
         * @type {string}
         */
        this.$template = "{{text}}";
        /**
         * @property $headerTemplate
         * @private
         * @type {string}
         */
        this.$headerTemplate = "{{text}}";

        /**
         * @property $placeHolder
         * @private
         * @type {HTMLElement}
         */
        this.$placeHolder = null;

        /**
         * @property $empty
         * @private
         * @type {HTMLElement}
         */
        this.$empty = null;

        this.$selectedItems = [];

        this.attr('style', 'normal');
        this.attr('sortable', false);
        this.attr('selectionMode', 'single');
        return this;
    }

    /**
     * Create a new list item.
     *
     * @method createItem
     * @private
     * @param {Object} curItem The data to bind to the item.
     * @param {Number} i The position of the item in the array.
     * @return {ListItem} The new item.
     */
    var createItem = function (curItem, i) {
        var item = new ListItem();
        item.parent(this);
        item.header(curItem.header === true);

        if (item.header()) {
            item.facet("item", (new Html()).attr("html", this.$headerTemplate).attr("data", curItem));
        } else {
            item.facet("item", (new Html()).attr("html", this.$template).attr("data", curItem));
        }

        item.update();

        item.el()._meems_parentList = this;
        item.el()._meems_item_index = i;
        item.el()._meems_item = curItem;

        return item;
    };

    var updateHeaderClasses = function () {
        var item, i, ln;

        if (this.$generatedItems) {
            for (i = 0, ln = this.$generatedItems.length; i < ln; ++i) {
                item = this.$generatedItems[i];

                if (!item.header()) {
                    if (i < ln - 1) {
                        if (this.$generatedItems[i + 1].header()) {
                            Utils.Dom.addClass(item.el(), "ui-list-item-last");
                        } else {
                            Utils.Dom.removeClass(item.el(), "ui-list-item-last");
                        }
                    } else {
                        Utils.Dom.addClass(item.el(), "ui-list-item-last");
                    }
                }
            }

            Utils.Dom.applyChanges();
        }
    };

    /**
     * Update the items DOM, based of the array of items before and after.
     *
     * @method updateItems
     * @private
     * @param {Object[]} oldItems The items before.
     * @param {Object[]|Function} newItems The new items.
     */
    var updateItems = function (oldItems, newItems) {
        if (!this.el()) {
            return;
        }

        newItems = typeof(newItems) === 'function' ? newItems() : newItems;
        var item, curItem, i, ln, el = this.el(), j, ln2;
        var processed = {};

        var oldParent = el.parentNode,
            oldChildIndex = 0;

        if (oldParent) {
            oldChildIndex = Array.prototype.indexOf.call(oldParent.childNodes, el);
            oldParent.removeChild(el);
            console.log("remove list parent");
        }

        if (this.$generatedItems) {
            for (i = 0, ln = this.$generatedItems.length; i < ln; ++i) {
                item = this.$generatedItems[i];

                var found = false;
                for (j = 0, ln2 = newItems.length; j < ln2; ++j) {
                    if (item.el()._meems_item === newItems[j]) {
                        found = true;
                        processed[j] = i;
                        Utils.Dom.removeClass(item.el(), "ui-list-item-last");
                        el.removeChild(item.el());
                        break;
                    }
                }

                if (!found && item.el() && item.el().parentNode === el) {
                    el.removeChild(item.el());
                    this.$generatedItems.splice(i, 1);
                    var iSelected = this.$selectedItems.indexOf(item);
                    if (iSelected > -1) {
                        this.$selectedItems.splice(iSelected, 1);
                    }
                    --i;
                    --ln;
                }
            }
        }

        for (i = 0, ln = newItems.length; i < ln; ++i) {
            curItem = newItems[i];

            if (processed[i] === undefined) {
                item = createItem.call(this, curItem, i, ln);
                this.$generatedItems.splice(i, 0, item);
            } else {
                item = this.$generatedItems[processed[i]];
            }

            el.appendChild(item.el());

            if (!item.header()) {
                if (i < ln - 1) {
                    if (newItems[i + 1].header === true) {
                        Utils.Dom.addClass(item.el(), "ui-list-item-last");
                    } else {
                        Utils.Dom.removeClass(item.el(), "ui-list-item-last");
                    }
                } else {
                    Utils.Dom.addClass(item.el(), "ui-list-item-last");
                }
            }
        }

        if (!this.$emptyIsVisible && this.$generatedItems.length == 0) {
            el.appendChild(this.$empty);
            this.$emptyIsVisible = true;
        } else if (this.$emptyIsVisible && this.$generatedItems.length > 0) {
            el.removeChild(this.$empty);
            this.$emptyIsVisible = false;
        }

        if (oldParent) {
            oldParent.insertBefore(el, oldParent.childNodes[oldChildIndex]);
            console.log("inserted list parent");
        }
    };

    /**
     * Fired when an item is clicked.
     *
     * @event item:clicked
     * @param {String} eventName The event name.
     * @param {Event|observable.Observable} e The item object associated with the item that was clicked.
     */
    var onItemClicked = function (eventName, e) {
        var target = e.target;

        while(target && target._meems_item_index === undefined) {
            target = target.parentNode;
        }

        if (target) {
            this.fire("item:clicked", target._meems_item, e);
        }

        return true;
    };

    List.extend(Widget, {
        /**
         * Getter and setter for the template of an item.
         *
         * @method template
         * @param {String} [val] The new template
         * @chainable
         * @return {String|List} If no parameter is provided, the current value is returned.
         * Otherwise, the new value is stored and the List itself is returned to allow chaining.
         */
        template : function (val) {
            if (val === undefined) {
                return this.$template;
            } else {
                this.$template = val;
            }

            return this;
        },

        /**
         * Getter and setter for the template of a header item.
         *
         * @method headerTemplate
         * @param {String} [val] The new template
         * @chainable
         * @return {String|List} If no parameter is provided, the current value is returned.
         * Otherwise, the new value is stored and the List itself is returned to allow chaining.
         */
        headerTemplate : function (val) {
            if (val === undefined) {
                return this.$headerTemplate;
            } else {
                this.$headerTemplate = val;
            }

            return this;
        },

        /**
         * Getter and setter for the items of the list.
         *
         * @method item
         * @param {|observable.Observable|Object[]|observable.Observable[]} [items] The new items.
         * @chainable
         * @return {|observable.Observable|Object[]|observable.Observable[]|List} If no parameter is provided, the current value is returned.
         * Otherwise, the new value is stored and the List itself is returned to allow chaining.
         */
        items: function (items) {
            if (items === undefined) {
                return this.$items;
            } else {
                this.$items = items;

                updateItems.call(this, null, this.$items);

                if (typeof(this.$items.subscribe) === 'function') {
                    this.$items.subscribe(Utils.Fn.bind(updateItems, this));
                }

                return this;
            }
        },

        attr : function (name, val) {
            var oldStyle = name === 'style' ? Widget.prototype.attr.call(this, name) : null;
            var ret = Widget.prototype.attr.apply(this, arguments);

            if (name === 'style' && val !== undefined && this.el()) {
                if (oldStyle) {
                    Utils.Dom.removeClass(this.el(), "ui-list-" +  oldStyle);
                }

                if (val) {
                    Utils.Dom.addClass(this.el(), "ui-list-" +  val);
                }
            } else if (name === 'empty' && this.$empty) {
                Utils.Dom.setHtml(this.$empty, val);
            }

            return ret;
        },

        getSelectedItems : function () {
            return this.$selectedItems;
        },

        update : function (structureOnly) {
            if (!this.el()) {
                this.el(document.createElement("ul"));
                this.el().className =  "ui-list";
                this.on("dom:" + Events.Touch.touchEndEventName, Utils.Fn.bind(onItemClicked, this));
                this.$placeHolder = document.createElement("li");
                this.$placeHolder.className = "ui-list-item ui-list-placeholder";
                this.$empty = document.createElement("li");
                this.$empty.className = "ui-list-empty";
                this.$empty.innerHTML = this.attr("empty") || "No data.";
                this.el().appendChild(this.$empty);
                this.$emptyIsVisible = true;
                this.on("item:checked", function (eventName, item, isChecked) {
                    if (isChecked) {
                        this.$selectedItems.push(item.el()._meems_item);
                    } else {
                        this.$selectedItems.splice(this.$selectedItems.indexOf(item.el()._meems_item), 1);
                    }

                    this.fire("selection:changed", this.$selectedItems);
                });
            }

            if (structureOnly !== true) {
                this.attr('style', this.attr('style'));
                updateItems.call(this, null, this.$items);
            }
            
            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return List;
});

/*global define*/
/**
 * A component that holds a menu and a content area, allowing the menu to be toggled on and off.
 *
 * @module meems-ui
 * @submodule aside
 * @requires meems-utils
 */
define('ui/aside',["meems-utils", "./widget"], function (Utils, Widget) {
    

    /**
     * @class Aside
     * @constructor
     * @extends Widget
     */
    function Aside() {
        Widget.apply(this, arguments);
        
        this.$expanded = false;
        
        this.facet("menu", null);
        this.facet("content", null);
        
        return this;
    }
    
    Aside.extend(Widget, {
        /**
         * Getter and setter for the menu's visibility.
         *
         * @method expanded
         * @param {Boolean} [val] True to show the menu, false to
         *                        hide the menu or undefined to return the current value.
         * @return {Aside|Boolean} If used as getter, returns the current visibility state of the menu,
         *                          otherwise returns the Aside widget itself to allow chaining.
         */
        expanded : function (val) {
            if (val === undefined) {
                return this.$expanded;
            } else {
                this.$expanded = val;
                
                if (this.$expanded) {
                    if (this.facet("menu")) {
                        Utils.Dom.addClass(this.facet("menu").el(), "ui-expanded");
                        Utils.Dom.removeClass(this.facet("menu").el(), "ui-collapsed");
                    }
                    
                    if (this.facet("content")) {
                        Utils.Dom.addClass(this.facet("content").el(), "ui-expanded");
                        Utils.Dom.removeClass(this.facet("content").el(), "ui-collapsed");
                    }
                } else {
                    if (this.facet("menu")) {
                        Utils.Dom.addClass(this.facet("menu").el(), "ui-collapsed");
                        Utils.Dom.removeClass(this.facet("menu").el(), "ui-expanded");
                    }
                    
                    if (this.facet("content")) {
                        Utils.Dom.addClass(this.facet("content").el(), "ui-collapsed");
                        Utils.Dom.removeClass(this.facet("content").el(), "ui-expanded");
                    }
                }
                
                return this;
            }
        },

        update : function (structureOnly) {
            if (!this.el()) {
                this.el(document.createElement("div"));
                Utils.Dom.addClass(this.el(), "ui-aside");
            }
            
            if (this.facet("menu")) {
                this.facet("menu").update(structureOnly);
                
                Utils.Dom.addClass(this.facet("menu").el(), "ui-aside-menu");
                
                if (this.facet("menu").el().parentNode !== this.el()) {
                    this.el().appendChild(this.facet("menu").el());
                }
            }
            
            if (this.facet("content")) {
                this.facet("content").update(structureOnly);
                
                Utils.Dom.addClass(this.facet("content").el(), "ui-aside-content");
                
                if (this.facet("content").el().parentNode !== this.el()) {
                    Utils.Dom.addClass(this.facet("content").el(), "ui-content ui-scroll-y");
                    this.el().appendChild(this.facet("content").el());
                }
            }
            
            this.expanded(this.$expanded);
            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return Aside;
});

/*global define*/
/**
 * Component that holds two widgets and puts them side by side.
 * Exposes the facets `first` and `second`.
 *
 * @module meems-ui
 * @submodule splitview
 * @requires meems-utils
 */
define('ui/split_view',["meems-utils", "./widget"], function (Utils, Widget) {
    

    /**
     * @class SplitView
     * @constructor
     * @extends Widget
     */
    function SplitView() {
        Widget.apply(this, arguments);

        this.attr('layout', 'horizontal');
        
        this.facet("first", null);
        this.facet("second", null);
        
        return this;
    }
    
    SplitView.extend(Widget, {
        attr : function (name, val) {
            var oldStyle = name === 'layout' ? Widget.prototype.attr.call(this, name) : null;
            var ret = Widget.prototype.attr.apply(this, arguments);

            if (name === 'layout' && val !== undefined && this.el()) {
                if (oldStyle) {
                    Utils.Dom.removeClass(this.el(), "ui-" + oldStyle);
                }

                if (val) {
                    Utils.Dom.addClass(this.el(), "ui-" + val);
                }
            }

            return ret;
        },

        update : function (structureOnly) {
            if (!this.el()) {
                this.el(document.createElement("div"));
                this.el().className = "ui-splitview";
                this.attr('layout', this.attr('layout'));
            }
            
            if (this.facet("first")) {
                this.facet("first").update(structureOnly);
                
                if (this.facet("first").el().parentNode !== this.el()) {
                    this.el().appendChild(this.facet("first").el());
                }
            }
            
            if (this.facet("second")) {
                this.facet("second").update(structureOnly);
                
                if (this.facet("second").el().parentNode !== this.el()) {
                    this.el().appendChild(this.facet("second").el());
                }
            }
            
            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return SplitView;
});

/*global define*/
/**
 * A tab to be used with the `TabGroup` component.
 * Exposes the `content` facet.
 *
 * @module meems-ui
 * @submodule tab
 * @requires meems-utils
 * @requires meems-scroll
 */
define('ui/tab',["meems-utils", "meems-scroll", "./widget"], function (Utils, Scroll, Widget) {
    

    /**
     * @class Tab
     * @constructor
     * @extends Widget
     */
    function Tab() {
        Widget.apply(this, arguments);
        this.$scroller = null;
        this.$holder = null;
        this.facet('content', null);
        return this;
    }
    
    Tab.extend(Widget, {
        update : function (structureOnly) {
            if (!this.el()) {
                this.el(document.createElement("div"));
                this.el().className = "ui-tab";
            }
            
            var facetContent = this.facet("content");
            
            if (facetContent) {
                facetContent.update(structureOnly);
                
                if (!this.$holder) {
                    this.$holder = document.createElement("div");
                    this.$holder.className = "ui-fill-width";
                    this.el().appendChild(this.$holder);
                }

                if (facetContent.el().parentNode !== this.$holder) {
                    this.$holder.appendChild(facetContent.el());
                    
                    if (this.$scroller) {
                        this.$scroller.destroy();
                    }
                    
                    this.$scroller = new Scroll(this.el(), {
                        scrollX: false,
                        scrollY: true
                    });
                }
            }
            
            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return Tab;
});

/*global define*/
/**
 * Groups several tabs and allows to change between them.
 *
 * @module meems-ui
 * @submodule tabgroup
 * @requires meems-utils
 * @requires meems-scroll
 * @requires meems-ui/button
 * @requires meems-ui/buttongroup
 */
define('ui/tab_group',["meems-utils", "meems-scroll", "./widget", "./tab", "./button_group", "./button"],
function (Utils, Scroll, Widget, Tab, ButtonGroup, Button) {
    

    /**
     * @class TabGroup
     * @constructor
     * @extends Widget
     */
    function TabGroup() {
        Widget.apply(this, arguments);
        /**
         * @property $tabs
         * @private
         * @type {Tab[]}
         */
        this.$tabs = [];

        /**
         * @property $visibleTab
         * @private
         * @type {number}
         */
        this.$visibleTab = 0;

        /**
         * @property $scroller
         * @private
         * @type {Scroll}
         */
        this.$scroller = null;
        /**
         * @property $tabHolder
         * @private
         * @type {HTMLElement}
         */
        this.$tabHolder = null;

        /**
         * @property $buttonGroup
         * @private
         * @type {ButtonGroup}
         */
        this.$buttonGroup = null;
        return this;
    }
    
    var onButtonTapped = function (eventName, e) {
        var target = e.target;
        while (target && target.className.indexOf("ui-button") === -1) {
            target = target.parentNode;
        }
        
        if (target) {
            var tabIndex = Utils.Array.indexOfByProp(this.$buttonGroup.buttons, "$el", target);
            if (tabIndex > -1) {
                this.visibleTab(tabIndex);
            }
        }
    };

    var onScrollEnd = function (eventName, x) {
        var page = Math.round(x / this.el().offsetWidth);
        this.visibleTab(page);
        this.update();
        Utils.Dom.applyChanges();
    };
    
    TabGroup.extend(Widget, {
        /**
         * Adds a new tab to the group.
         *
         * @method addTab
         * @param {Tab} tab The new tab to add.
         * @chainable
         */
        addTab : function (tab) {
            this.$tabs.push(tab);
            return this;
        },

        /**
         * Getter and setter for the visible page.
         *
         * @method visibleTab
         * @param {Number} [index] Position of page in the array.
         * @return {Number|TabGroup} `this` if called as a setter, the current page if called as getter.
         */
        visibleTab : function (index) {
            if (index === undefined) {
                return this.$visibleTab;
            } else {
                if (index < 0 || index >= this.$tabs.length) {
                    return this;
                }
                
                if (index !== this.$visibleTab && this.$scroller) {
                    this.$scroller.scrollTo(index * this.el().offsetWidth);
                    this.$visibleTab = index;
                }
            
                return this;
            }
        },

        /**
         * Getter for all the tabs.
         *
         * @method tabs
         * @return {Tab[]} The array to tabs.
         */
        tabs : function () {
            return this.$tabs;
        },

        partialUpdate : function (attrName, oldValue, newValue) {
            if (attrName === 'tabPosition' && this.el()) {
                Utils.Dom.removeClass(this.el(), "ui-tab-buttons-" + oldValue);
                Utils.Dom.addClass(this.el(), "ui-tab-buttons-" + newValue);
            }
        },
        
        update : function (structureOnly) {
            if (!this.el()) {
                this.el(document.createElement("div"));
                this.el().className = "ui-tab-group";
                
                this.$tabHolder = document.createElement("div");
                this.$helperHolder = document.createElement("div");
                this.$buttonGroup = document.createElement("div");
                
                this.$tabHolder.className = "ui-fill";
                this.$helperHolder.className = "ui-tab-holder ui-fill";
                this.$buttonGroup.className = "ui-tab-buttons";
                this.$buttonGroup.buttons = [];
                
                this.$helperHolder.appendChild(this.$tabHolder);
                this.el().appendChild(this.$helperHolder);
                
                var position = this.attr("tabPosition") || 'top';
                
                if (position === 'top') {
                    this.el().className += " ui-tab-buttons-top";
                } else {
                    this.el().className += " ui-tab-buttons-bottom";
                }
                
                this.el().appendChild(this.$buttonGroup);
            }
            
            if (this.$tabs.length > 0) {
                var tab, btn,
                    tabSize = 100.0 / this.$tabs.length;
                this.$tabHolder.style.width = this.$tabs.length * 100 + "%";
                
                for (var i = 0, ln = this.$tabs.length; i < ln; ++i) {
                    tab = this.$tabs[i];
                    
                    tab.update(structureOnly);
                    
                    if (tab.el().parentNode !== this.$tabHolder) {
                        tab.el().style.position = "absolute";
                        tab.el().style.left = i * tabSize + "%";
                        tab.el().style.top = "0";
                        tab.el().style.width = tabSize + "%";
                        tab.el().style.bottom = "0";
                        this.$tabHolder.appendChild(tab.el());
                        
                        btn = (new Button()).attr("style", "vertical");
                        btn.update(structureOnly);
                        btn.on("dom:" + (Utils.Dom.supportsTouch() ? "touchstart" : "click"),
                            Utils.Fn.bind(onButtonTapped, this));
                            
                        this.$buttonGroup.appendChild(btn.el());
                        this.$buttonGroup.buttons.push(btn);
                    }
                    
                    btn = btn || this.$buttonGroup.buttons[i];
                    btn.attr("title", tab.attr("title")).attr("icon", tab.attr("icon"))
                       .attr("disabled", this.$visibleTab !== i);
                    btn.update(structureOnly);
                    btn.el().style.width = tabSize + "%";
                    
                    if (i === this.$visibleTab) {
                        Utils.Dom.addClass(btn.el(), "ui-selected");
                    } else {
                        Utils.Dom.removeClass(btn.el(), "ui-selected");
                    }
                    
                    btn = null;
                }
                
                Utils.Dom.addClass(this.$tabHolder, "ui-footer-on");
                
                if (!this.$scroller) {
                    this.$scroller = new Scroll(this.$helperHolder, {
                        scrollX: true,
                        scrollY: false,
                        bouncing: false,
                        paging: true,
                        totalMaxTime: 0.25,
                        disableTouchEvents : false,
                        hideScroller : true
                    }).on("scroll:end", Utils.Fn.bind(onScrollEnd, this));
                }
            } else {
                Utils.Dom.addClass(this.$tabHolder, "ui-footer-off");
            }
            
            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return TabGroup;
});

/*global define*/
/**
 * A form that can hold several input widgets.
 * The attributes 'action' and 'title' are available.
 *
 * @module meems-ui
 * @submodule form
 * @requires meems-utils
 */
define('ui/form',["meems-utils", "./widget"], function (Utils, Widget) {
    

    /**
     * @class Form
     * @constructor
     * @extends Widget
     */
    function Form() {
        Widget.apply(this, arguments);
        this.$titleEl = null;
        this.$holder = null;
        this.$fields = [];
        return this;
    }
    
    Form.extend(Widget, {
        /**
         * Add a new field to the form.
         *
         * @method addField
         * @param {Widget} field
         * @chainable
         */
        addField : function (field) {
            this.$fields.push(field);
            return this;
        },

        /**
         * Getter and setter for the fields of the form.
         *
         * @method fields
         * @param {Widget[]} [val] Array with the new fields
         * @return {Widget} If no parameter is provided, the current value is returned.
         * Otherwise, the new value is stored and the Form itself is returned to allow chaining.
         */
        fields : function (val) {
            if (val === undefined) {
                return this.$fields;
            } else {
                this.$fields = val;
                return this;
            }
        },

        partialUpdate : function (attrName, oldValue, newValue) {
            if (attrName === 'action' && this.el()) {
                this.el().setAttribute("action", newValue || "#");
            } else if (attrName === 'title' && this.$titleEl) {
                Utils.Dom.setHtml(this.$titleEl, newValue);
                if (newValue.length > 0) {
                    Utils.Dom.addClass(this.$titleEl, 'ui-show');
                    Utils.Dom.removeClass(this.$titleEl, 'ui-hide');
                } else {
                    Utils.Dom.addClass(this.$titleEl, 'ui-hide');
                    Utils.Dom.removeClass(this.$titleEl, 'ui-show');
                }
            }
        },
        
        update : function (structureOnly) {
            if (!this.el()) {
                this.el(document.createElement("form"));
                this.el().className = "ui-form";
                this.el().setAttribute("action", this.attr("action") || "#");
                
                this.$titleEl = document.createElement("div");
                this.$titleEl.className = "ui-title";
                this.el().appendChild(this.$titleEl);
                
                this.$holder = document.createElement("div");
                this.$holder.className = "ui-form-fields";
                this.el().appendChild(this.$holder);
            }

            var newTitle = this.attr("title") || "";
            Utils.Dom.setHtml(this.$titleEl, newTitle);
            if (newTitle.length > 0) {
                Utils.Dom.addClass(this.$titleEl, 'ui-show');
                Utils.Dom.removeClass(this.$titleEl, 'ui-hide');
            } else {
                Utils.Dom.addClass(this.$titleEl, 'ui-hide');
                Utils.Dom.removeClass(this.$titleEl, 'ui-show');
            }
            
            var field;
            
            for (var i = 0; i < this.$fields.length; ++i)  {
                field = this.$fields[i];
                field.update(structureOnly);
                
                if (field.el().parentNode !== this.$holder) {
                    this.$holder.appendChild(field.el());
                }
            }
            
            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return Form;
});

/*global define*/
/**
 * A component that allows the user to input information.
 * Exposes the attributes `label` and `type`.
 * The later can be used to change the type of input it expects, according to the HTML5 specs.
 *
 * @module meems-ui
 * @submodule textfield
 * @requires meems-utils
 */
define('ui/textfield',["meems-utils", "meems-events", "./widget"], function (Utils, Events, Widget) {
    

    /**
     * @class TextField
     * @constructor
     * @extends Widget
     */
    function TextField() {
        /**
         * @property $input
         * @private
         * @type {HTMLElement}
         */
        this.$input = null;

        /**
         * @property $label
         * @private
         * @type {String}
         */
        this.$label = null;

        this.$value = null;

        Widget.apply(this, arguments);
        return this;
    }

    var updateTextField = function (oldVal, newVal) {
        if (this.$input) {
            this.$input.value = newVal;
        }
    };
    
    TextField.extend(Widget, {
        /**
         * Getter and setter for the value of the field.
         *
         * @method value
         * @param {observable.Observable|String} [val] The new value.
         * @return {TextField|observable,Observable|String} `this` if called as a setter,
         * the current value otherwise.
         */
        value : function (val) {
            if (val === undefined) {
                if (typeof(this.$value) === 'function') {
                    return this.$value;
                } else {
                    return this.$input.value;
                }
            } else {
                this.$value = val;
                updateTextField.call(this, null, val);
                return this;
            }
        },

        partialUpdate : function (attrName, oldValue, newValue) {
            if (attrName === 'label' && this.$label) {
                Utils.Dom.setHtml(this.$label, newValue || "");
            }
        },

        update : function () {
            if (!this.el()) {
                this.el(document.createElement("div"));
                this.$label = document.createElement("label");
                this.$input = document.createElement("input");
                this.$input.setAttribute("type", this.attr("type") || "text");
                this.el().appendChild(this.$label);
                var tmp = document.createElement("div");
                tmp.appendChild(this.$input);
                this.el().appendChild(tmp);
                this.el().className = "ui-textfield";

                Events.Dom.on(this.$input, 'change', Utils.Fn.bind(function () {
                    if (typeof(this.$value) === 'function') {
                        this.$value(this.$input.value);
                    }
                }, this));

                Events.Dom.on(this.$input, 'focus', Utils.Fn.bind(function () {
                    Utils.Dom.addClass(this.el(), "ui-focused");
                    Utils.Dom.applyChanges();
                }, this));

                Events.Dom.on(this.$input, 'blur', Utils.Fn.bind(function () {
                    Utils.Dom.removeClass(this.el(), "ui-focused");
                    Utils.Dom.applyChanges();
                }, this));

                if (typeof (this.$value) === 'function') {
                    if ("subscribe" in this.$value) {
                        this.$value.subscribe(updateTextField);
                    }
                }
            }
            
            Utils.Dom.setHtml(this.$label, this.attr("label") || "");
            
            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return TextField;
});

/*global define*/
/**
 * A bag for all the pages in a program. Allows to transition between pages.
 *
 * @module meems-ui
 * @submodule pageholder
 * @requires meems-utils
 */
define('ui/page_holder',["meems-utils", "./widget", "./page"], function (Utils, Widget, Page) {
    

    /**
     * @class PageHolder
     * @constructor
     * @extends Widget
     */
    function PageHolder() {
        Widget.apply(this, arguments);

        /**
         * @property $pages
         * @private
         * @type Page[]
         */
        this.$pages = [];

        /**
         * @property $currentPage
         * @private
         * @type Page
         */
        this.$currentPage = null;
        return this;
    }
    
    PageHolder.extend(Widget, {
        /**
         * Getter and setter for all the pages in the bag.
         *
         * @method pages
         * @param {Page[]} [val] Array with the new pages.
         * @chainable
         * @return {Page[]|PageHolder} `this` if called as a setter, the current array of pages otherwise.
         */
        pages : function (val) {
            if (val === undefined) {
                return this.$pages;
            } else {
                var page, i, len;

                if (this.$pages) {
                    for (i = 0, len = this.$pages.length; i < len; ++i) {
                        page = this.$pages[i];
                        if (page.el() && page.el().parentNode === this.el()) {
                            this.el().removeChild(page.el());
                        }
                    }
                }

                this.$pages = val;
                
                if (this.$pages) {
                    for (i = 0, len = this.$pages.length; i < len; ++i) {
                        page = this.$pages[i];
                        if (page.el() && page.el().parentNode !== this.el()) {
                            this.el().appendChild(page.el());
                        }
                    }
                }

                return this;
            }
        },

        /**
         * Getter and setter for the current page.
         *
         * @method currentPage
         * @param {Page} [val] The page to go to.
         * @chainable
         * @return {Page|PageHolder} `this` if called as a setter, the current page otherwise.
         */
        currentPage : function (val) {
            if (val === undefined) {
                return this.$currentPage;
            } else {
                if (this.$currentPage) {
                    Utils.Dom.removeClass(this.$currentPage.el(), "ui-show");
                    Utils.Dom.addClass(this.$currentPage.el(), "ui-hide");
                }

                this.$currentPage = val;

                if (this.$currentPage) {
                    Utils.Dom.removeClass(this.$currentPage.el(), "ui-hide");
                    Utils.Dom.addClass(this.$currentPage.el(), "ui-show");
                }

                return this;
            }
        },

        update : function (structureOnly) {
            if (!this.el()) {
                this.el(document.createElement("div"));
                this.el().className = "ui-page-holder";
            }
            
            if (this.$pages) {
                var page;

                for (var i = 0, len = this.$pages.length; i < len; ++i) {
                    page = this.$pages[i];
                    page.update(structureOnly);

                    if (page.el() && page.el().parentNode !== this.el()) {
                        this.el().appendChild(page.el());
                    }

                    if (!this.$currentPage) {
                        this.$currentPage = page;
                    }
                    
                    if (page.el()) {
                        if (this.$currentPage === page) {
                            Utils.Dom.removeClass(this.$currentPage.el(), "ui-hide");
                            Utils.Dom.addClass(this.$currentPage.el(), "ui-show");
                        } else {
                            Utils.Dom.addClass(page.el(), "ui-hide");
                            Utils.Dom.removeClass(page.el(), "ui-show");
                        }
                    }
                }
            }

            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return PageHolder;
});

/*global define*/
define('ui/group',["meems-utils", "./widget"],
/**
 * Enables the grouping of several components in the same view.
 *
 * @module meems-ui
 * @submodule group
 * @requires meems-utils
 */
function (Utils, Widget) {
    

    /**
     * @class Group
     * @constructor
     * @extends Widget
     */
    function Group() {
        Widget.apply(this, arguments);

        this.$children = [];
        
        return this;
    }

    Group.extend(Widget, {
        /**
         * Getter and Setter for the children widgets.
         *
         * @method children
         * @param {Widget[]} [val] New array of children.
         * @chainable
         * @return {Widget[]|Group} `this` when used as a setter, the current children otherwise.
         */
        children : function (val) {
            if (val === undefined) {
                return this.$children;
            } else {
                var child, i, ln;

                if (this.$children) {
                    for (i = 0, ln = this.$children.length; i < ln; ++i) {
                        child = this.$children[i];
                        if (child.el().parentNode === this.el()) {
                            this.el().removeChild(child.el());
                        }
                    }
                }

                this.$children = val;

                for (var i = 0, ln = this.$children.length; i < ln; ++i) {
                    child = this.$children[i];

                    if (child.el() && child.el().parentNode !== this.el()) {
                        this.el().appendChild(child.el());
                    }
                }

                return this;
            }
        },

        /**
         * Add a widget to the group.
         *
         * @method appendChild
         * @param {Widget} child The widget to add
         * @chainable
         */
        appendChild : function (child) {
            this.$children.push(child);

            if (this.el()) {
                if (child.el() && child.el().parentNode !== this.el()) {
                    this.el().appendChild(child.el());
                }
            }

            return this;
        },

        /**
         * Remove a widget from the group.
         *
         * @method removeChild
         * @param {Widget} child The widget to remove.
         * @chainable
         */
        removeChild : function (child) {
            Utils.Array.remove(this.$children, child);

            if (this.el()) {
                if (child.el() && child.el().parentNode === this.el()) {
                    this.el().removeChild(child.el());
                }
            }

            return this;
        },

        update : function (structureOnly) {
            if (!this.el()) {
                this.el(document.createElement("div"));
                this.el().className = "ui-group";
            }

            var child;

            for (var i = 0, ln = this.$children.length; i < ln; ++i) {
                child = this.$children[i];
                child.update(structureOnly);

                if (child.el().parentNode !== this.el()) {
                    this.el().appendChild(child.el());
                }
            }

            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return Group;
});

/*global define*/
/**
 * A toggle button that allows a user to set something on or off.
 * Exposes the attributes `label`.
 *
 * @module meems-ui
 * @submodule switch
 * @requires meems-utils
 */
define('ui/switch',["meems-utils", "meems-events", "./widget"], function (Utils, Events, Widget) {
    

    /**
     * @class Switch
     * @constructor
     * @extends Widget
     */
    function Switch() {
        /**
         * @property $input
         * @private
         * @type {HTMLElement}
         */
        this.$input = null;

        /**
         * @property $label
         * @private
         * @type {String}
         */
        this.$label = null;

        this.$value = false;

        Widget.apply(this, arguments);
        return this;
    }

    var updateInput = function (oldVal, newVal) {
        var nV = typeof(newVal) === 'function' ? newVal() : newVal;

        if (this.$input) {
            this.$input.checked = nV;
        }
    };

    Switch.extend(Widget, {
        /**
         * Getter and setter for the value of the field.
         *
         * @method value
         * @param {observable.Observable|String} [val] The new value.
         * @return {TextField|observable,Observable|String} `this` if called as a setter,
         * the current value otherwise.
         */
        value : function (val) {
            if (val === undefined) {
                return this.$value;
            } else {
                updateInput.call(this, this.$value, val);
                this.$value = val;
                return this;
            }
        },

        partialUpdate : function (attrName, oldValue, newValue) {
            if (attrName === 'label' && this.$label) {
                Utils.Dom.setHtml(this.$label, newValue || "");
            }
        },

        update : function () {
            if (!this.el()) {
                this.el(document.createElement("div"));
                this.$label = document.createElement("label");
                this.$input = document.createElement("input");
                this.$inputLabel = document.createElement("label");
                this.$inputLabel.appendChild(document.createElement("b"));
                this.$input.setAttribute("type", "checkbox");
                this.$input.setAttribute("checked", "checkbox");

                var div = document.createElement("div");
                updateInput.call(this, null, this.$value);
                div.appendChild(this.$input);
                div.appendChild(this.$inputLabel);
                this.el().appendChild(this.$label);
                this.el().appendChild(div);
                this.el().className = "ui-switch";

                Events.Dom.on(div, Events.Touch.touchEndEventName, Utils.Fn.bind(function () {
                    if (typeof(this.$value) === 'function') {
                        var newVal = !this.$value();
                        this.$input.checked = newVal;
                        this.$value(newVal);
                    } else {
                        updateInput.call(this, this.$value, !this.$value);
                        this.$value = !this.$value;
                        this.$input.checked = this.$value;
                    }
                    Utils.Dom.applyChanges();
                }, this));

                if (typeof (this.$value) === 'function') {
                    if ("subscribe" in this.$value) {
                        this.$value.subscribe(Utils.Fn.bind(updateInput, this));
                    }
                }
            }
            
            Utils.Dom.setHtml(this.$label, this.attr("label") || "");
            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return Switch;
});

/*global define*/
/**
 * A slider that allows the user to choose a value between a minimum and a maximum.
 * Exposes the attributes `label`, `minimum`, `maximum`.
 *
 * @module meems-ui
 * @submodule slider
 * @requires meems-utils
 */
define('ui/slider',["meems-utils", "meems-events", "./widget"], function (Utils, Events, Widget) {
    

    /**
     * @class Slider
     * @constructor
     * @extends Widget
     */
    function Slider() {
        /**
         * @property $input
         * @private
         * @type {HTMLElement}
         */
        this.$input = null;

        /**
         * @property $label
         * @private
         * @type {String}
         */
        this.$label = null;

        this.$value = false;

        Widget.apply(this, arguments);
        return this;
    }

    var updateInput = function (oldVal, newVal) {
        var nV = typeof(newVal) === 'function' ? newVal() : newVal;

        if (this.$input) {
            var min = this.attr('minimum') || 0,
                max = this.attr('maximum') || 100,
                perc = Math.max(Math.min((nV - min) / (max - min), 1), 0) * 100;

            this.$inputBar.style.width = perc + '%';

            /*var handleRelSize = this.$inputHandle.offsetWidth / 2.0 / (this.$input.offsetWidth * 1.0) * 100.0;

            if (perc >= 100.0 - handleRelSize) {
                perc = 100.0 - handleRelSize;
            } else if (perc < handleRelSize) {
                perc = handleRelSize;
            }*/

            this.$inputHandle.style.left = perc + '%';
        }
    };

    var onStartDrag = function (e) {
        if (this.$meems_ui_slider_move) {
            Events.Dom.off(this.$input, Events.Touch.touchMoveEventName, this.$meems_ui_slider_move);
        }

        if (this.$meems_ui_slider_end) {
            Events.Dom.off(this.$input, Events.Touch.touchEndEventName, this.$meems_ui_slider_end);
        }

        // The position of the cursor when the dragging started
        this.$meems_ui_slider_start_pos = Events.Touch.getCursorPosition(e);
        // The position of the slider
        this.$meems_ui_slider_pos = Utils.Dom.getAbsolutePosition(this.$input);
        this.$meems_ui_slider_size = Utils.Dom.getDimensions(this.$input);

        var x = this.$meems_ui_slider_start_pos.x - this.$meems_ui_slider_pos.x,
            value = Math.min(Math.max(x / this.$meems_ui_slider_size.width, 0), 1),
            min = this.attr('minimum') || 0,
            max = this.attr('maximum') || 100;

        value = value * (max - min) + min;

        if (typeof(this.$value) === 'function') {
            this.$value(value);
        } else {
            this.$value = value;
            updateInput.call(this, null, value);
        }

        // Register events.
        this.$meems_ui_slider_move = Utils.Fn.bind(onMoveDrag, this);
        this.$meems_ui_slider_end = Utils.Fn.bind(onEndDrag, this);
        Events.Dom.on(this.$input, Events.Touch.touchMoveEventName, this.$meems_ui_slider_move);
        Events.Dom.on(this.$input, Events.Touch.touchEndEventName, this.$meems_ui_slider_end);

        Utils.Dom.applyChanges();

        return Events.Dom.cancelEvent(e);
    };

    var onMoveDrag = function (e) {
        var pos = Events.Touch.getCursorPosition(e);

        var x = pos.x - this.$meems_ui_slider_pos.x,
            value = Math.min(Math.max(x / this.$meems_ui_slider_size.width, 0), 1),
            min = this.attr('minimum') || 0,
            max = this.attr('maximum') || 100;

        value = value * (max - min) + min;

        if (typeof(this.$value) === 'function') {
            this.$value(value);
        } else {
            this.$value = value;
            updateInput.call(this, null, value);
        }

        return Events.Dom.cancelEvent(e);
    };

    var onEndDrag = function () {
        // Un-register events.
        Events.Dom.off(this.$input, Events.Touch.touchMoveEventName, this.$meems_ui_slider_move);
        Events.Dom.off(this.$input, Events.Touch.touchEndEventName, this.$meems_ui_slider_end);
        this.$meems_ui_slider_end = null;
        this.$meems_ui_slider_move = null;
    };

    Slider.extend(Widget, {
        /**
         * Getter and setter for the value of the field.
         *
         * @method value
         * @param {observable.Observable|String} [val] The new value.
         * @return {TextField|observable,Observable|String} `this` if called as a setter,
         * the current value otherwise.
         */
        value : function (val) {
            if (val === undefined) {
                return this.$value;
            } else {
                updateInput.call(this, this.$value, val);
                this.$value = val;
                return this;
            }
        },

        partialUpdate : function (attrName, oldValue, newValue) {
            if (attrName === 'label' && this.$label) {
                Utils.Dom.setHtml(this.$label, newValue || "");
            }
        },

        update : function () {
            if (!this.el()) {
                this.el(document.createElement("div"));
                this.$label = document.createElement("label");

                this.$inputBar = document.createElement("div");
                this.$inputBar.className = "ui-bar";

                this.$inputHandle = document.createElement("div");
                this.$inputHandle.className = "ui-handle";

                this.$input = document.createElement("div");
                updateInput.call(this, null, this.$value);
                this.$input.appendChild(this.$inputBar);
                this.$input.appendChild(this.$inputHandle);
                this.el().appendChild(this.$label);
                this.el().appendChild(this.$input);
                this.el().className = "ui-slider";

                Events.Dom.on(this.$input, Events.Touch.touchStartEventName, Utils.Fn.bind(onStartDrag, this));

                if (typeof (this.$value) === 'function') {
                    if ("subscribe" in this.$value) {
                        this.$value.subscribe(Utils.Fn.bind(updateInput, this));
                    }
                }
            }
            
            Utils.Dom.setHtml(this.$label, this.attr("label") || "");
            Widget.prototype.update.apply(this, arguments); //super
        }
    });
    
    return Slider;
});

/*global define*/
/**
 * Provides all Meems UI components.
 * Factory module, allows the user to create any UI widget through a single method.
 *
 * @module meems-ui
 * @requires observable
 */
define('meems-ui',["./observable",
        "./ui/widget",
        "./ui/header",
        "./ui/footer",
        "./ui/page",
        "./ui/html",
        "./ui/button",
        "./ui/button_group",
        "./ui/list",
        "./ui/aside",
        "./ui/split_view",
        "./ui/tab_group",
        "./ui/tab",
        "./ui/form",
        "./ui/textfield",
        "./ui/page_holder",
        "./ui/group",
        "./ui/switch",
        "./ui/slider",
        "./ui/popup_menu"],
function (Observable, Widget, Header, Footer, Page,
          Html, Button, ButtonGroup, List,
          Aside, SplitView, TabGroup, Tab, Form,
          TextField, PageHolder, Group, Switch, Slider, PopupMenu) {
    

    /*
     * All available widget types.
     */
    var factories = {
        "header"     : Header,
        "footer"     : Footer,
        "page"       : Page,
        "html"       : Html,
        "button"     : Button,
        "buttongroup": ButtonGroup,
        "list"       : List,
        "aside"      : Aside,
        "splitview"  : SplitView,
        "tabgroup"   : TabGroup,
        "tab"        : Tab,
        "form"       : Form,
        "textfield"  : TextField,
        "pageholder" : PageHolder,
        "group"      : Group,
        "switch"     : Switch,
        "slider"     : Slider,
        "popupmenu"  : PopupMenu
    };

    /**
     * @class meems-ui
     */
    var UI = {
        /**
         * Creates a new widget.
         *
         * @method create
         * @static
         * @param {String} type The name of the type of widget to create.
         * @param {Widget} [parent] Registers the created widget as child of the given parent.
         * @return {mixed} The widget, or null in case of error.
         */
        create : function (type, parent) {
            var obj = factories[type] ? new factories[type]() : null;

            if (obj && parent) {
                obj.parent(parent);
            }

            return obj;
        },

        /**
         * Register a new type of widget.
         *
         * @method registerWidget
         * @param {String} name The name that will be used to identify this type of widget.
         * @param {Function} constructor The widget constructor.
         */
        registerWidget : function (name, constructor) {
            factories[name] = constructor;
        }
    };
    
    return UI;
});

/*global define*/
/**
 * Singleton manager of routes and application history.
 *
 * @module meems
 * @submodule router
 */
define('router',["meems-events"], function (Events) {
    var routes = [],
        findParamRegExp = /\/([:\?])([\w\d]+)/g;

    function getCallbackForRoute(route) {
        var r, m;

        for (var k = 0, len = routes.length; k < len; ++k) {
            r = routes[k];

            if ((m = r.route.exec(route))) {
                var params = {};

                for (var i = 0, len2 = r.params.length; i < len2; ++i) {
                    params[r.params[i]] = m[i+1];
                }

                return {
                    callback: r.callback,
                    params: params
                };
            }
        }

        return null;
    }

    function onHashChanged() {
        Router.goTo(window.location.hash.replace(/^#\/?/, ""), true);
    }

    /**
     * @class Router
     */
    var Router = {
        /**
         * Obtain the current location.
         *
         * @method get
         * @return {string} The current location
         */
        get : function () {
            return window.location.hash.replace(/^#\/?/, "");
        },

        /**
         * Associates a callback with a route.
         *
         * @method on
         * @param route The route to match.
         * @param callback The callback to be invoked.
         */
        on : function (route, callback) {
            var params = [];
            findParamRegExp.lastIndex = 0;

            // build a regular expression based on the provided route to capture arguments.
            var rexpRoute = route.replace(findParamRegExp, function (match, p1, p2) {
                params.push(p2);

                if (p1 === ':') {
                    return "\/([^/]+)";
                } else {
                    return "(?:\/([^/]+))?";
                }
            });

            var obj = {
                route: new RegExp(rexpRoute),
                params: params,
                callback: callback
            };

            routes.push(obj);
        },

        /**
         * Jump to a certain route.
         *
         * @method goTo
         * @param url Jump to the given url
         * @param [skipUpdateLocation] true if the window location is not to be updated.
         */
        goTo : function (url, skipUpdateLocation) {
            if (skipUpdateLocation !== true) {
                window.location.hash = "#" + url;
            } else {
                var cb = getCallbackForRoute(url);
                if (cb) {
                    cb.callback({
                        url: url,
                        params: cb.params
                    });
                }
            }
        },

        /**
         * Reads the current URL and invokes the appropriate handlers.
         * Call this after you've set up the route handlers.
         *
         * @method init
         */
        init : function ()  {
            Router.goTo(Router.get(), true);
        }
    };

    // Install a handler to listen for URL (hash) changes.
    (function() {
        if ("onhashchange" in window) {
            Events.Dom.on(window, 'hashchange', onHashChanged);
        } else {
            var hash = window.location.hash;
            window.setInterval(function () {
                if (hash !== window.location.hash) {
                    onHashChanged();
                    hash = window.location.hash;
                }
            }, 250);
        }
    }());

    return Router;
});
/*global define*/
/**
 * Provides all Meems UI components.
 * Factory module, allows the user to create any UI widget through a single method.
 *
 * @module meems
 * @requires observable meems-ui
 */
define('meems',["./observable",
        "./meems-ui",
        "meems-events",
        "meems-utils",
        "meems-scroll",
        "./router"],
function (Observable, UI, Events, Utils, Scroll, Router) {
    

    var Meems = {
        Observable: Observable,
        UI: UI,
        Events: Events,
        Utils: Utils,
        Scroll: Scroll,
        Router: Router
    };
    
    return Meems;
});
    return require('meems');
}));
